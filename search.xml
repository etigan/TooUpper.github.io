<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/OS/OS%20Course/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
      <url>/OS/OS%20Course/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: &quot;嵌入式工具介绍&quot;</span><br><span class="line">date: 2024-05-15 21:51:02</span><br><span class="line">categories: &quot;OS&quot;</span><br><span class="line">tags: </span><br><span class="line">- &quot;OS&quot;</span><br></pre></td></tr></table></figure><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>参与编译和运行的机器根据其角色可以分成以下三类</p><ul><li>构建(build)系统：<code>生成编译器可执行程序</code>的计算机系统。</li><li>主机(host)系统：<code>运行编译器可执行程序，编译链接应用程序</code>的计算机系统。</li><li>目标(target)系统：<code>运行应用程序</code>的计算机系统。</li></ul><p>根据 build&#x2F;host&#x2F;target 的不同组合我们可以得到如下的编译方式分类</p><ul><li>本地(native)编译：<strong>build &#x3D;&#x3D; host &#x3D;&#x3D; target</strong></li><li>交叉(cross)编译： <strong>build &#x3D;&#x3D; host !&#x3D; target</strong></li></ul><h2 id="调试器-GDB"><a href="#调试器-GDB" class="headerlink" title="调试器 GDB"></a>调试器 GDB</h2><h2 id="模拟器-QEMU"><a href="#模拟器-QEMU" class="headerlink" title="模拟器 QEMU"></a>模拟器 QEMU</h2><h2 id="项目构造工具"><a href="#项目构造工具" class="headerlink" title="项目构造工具"></a>项目构造工具</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存</title>
      <link href="/OS/OS%20Course/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/OS/OS%20Course/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>目标：</p><ul><li>是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。</li></ul><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><h2 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h2>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust中的函数和闭包</title>
      <link href="/Rust/basic/%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/"/>
      <url>/Rust/basic/%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="常规函数"><a href="#常规函数" class="headerlink" title="常规函数"></a>常规函数</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>函数都拥有显示的类型签名；</li><li>函数可分为三种类型：自由函数、关联函数和方法；</li><li>函数自身也是一种类型</li></ul><h4 id="自由函数"><a href="#自由函数" class="headerlink" title="自由函数"></a>自由函数</h4><h4 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h4><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h3 id="函数项类型"><a href="#函数项类型" class="headerlink" title="函数项类型"></a>函数项类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> (<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        a + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">math</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">sum</span>(<span class="keyword">self</span>.<span class="number">0</span>, <span class="keyword">self</span>.<span class="number">1</span>) <span class="comment">// 此处存在一个自动解引用 Self::sum((*self).0, (*self).1) </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">A</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add</span>: <span class="keyword">fn</span> <span class="title function_">sum</span>(<span class="type">i32</span>, <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> = A::sum; <span class="comment">// fn sum(i32, i32) -&gt; i32 是函数项类型也就是函数自己本身的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_math</span>: <span class="keyword">fn</span> <span class="title function_">math</span>(&amp;A) <span class="punctuation">-&gt;</span> <span class="type">i32</span> = A::math; <span class="comment">// 同上</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add</span>(<span class="number">1</span>, <span class="number">2</span>), A::<span class="title function_ invoke__">sum</span>(<span class="number">1</span>, <span class="number">2</span>));<span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add_math</span>(&amp;a),a.<span class="title function_ invoke__">math</span>());</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;A)); <span class="comment">// 大小为 0 函数项类型是零大小类型</span></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;a)); <span class="comment">// 大小为 8 (4（i32）+ 4（i32）= 8)</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="函数指针类型"><a href="#函数指针类型" class="headerlink" title="函数指针类型"></a>函数指针类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RGB</span> = (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">color</span>(c: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB &#123;</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shwo</span>(c: <span class="title function_ invoke__">fn</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB) &#123; <span class="comment">// 此处隐式转为了函数指针类型 是 fn(&amp;str) -&gt; RGB 类型</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c); <span class="comment">// 此处指针就是一个地址，所以可以被打印</span></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;c)); <span class="comment">// 8 函数指针大小为 8</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">c</span>(<span class="string">&quot;black&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb</span>: <span class="keyword">fn</span> <span class="title function_">color</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>) = color; <span class="comment">// 函数项类型  fn color(&amp;str) -&gt; (i16, i16, i16)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="keyword">fn</span> <span class="title function_">color</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>)  = rgb; <span class="comment">// 函数项类型</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, rgb); // 此处是函数项类型不可以被打印</span></span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(rgb);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;rgb)); <span class="comment">// 函数项大小为 0 函数项是零大小类型  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>结论：</strong></p><ul><li>函数项类型可以通过显式指定函数类型转换为一个函数指针类型；</li><li>在写代码的时候，尽可能地去使用 <em>函数项类型</em>，不到万不得已不要使用函数指针类型，这样有助于享受零大小类型的优化；</li></ul></blockquote><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="闭包与函数的异同"><a href="#闭包与函数的异同" class="headerlink" title="闭包与函数的异同"></a>闭包与函数的异同</h3><ol><li>闭包可以捕获环境中的自由变量；</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">counter</span>(i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">inc</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">         n + i <span class="comment">// error[E0434]: can&#x27;t capture dynamic environment in a fn item</span></span><br><span class="line">    &#125;</span><br><span class="line">    inc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> = <span class="title function_ invoke__">counter</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">f</span>(<span class="number">1</span>))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可改为：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">counter</span>(i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">move</span> | n | n + i <span class="comment">// move 关键字将环境变量 i 的所有权移动到闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span>: <span class="keyword">impl</span> <span class="title class_">FnMut</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> = <span class="title function_ invoke__">counter</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">f</span>(<span class="number">1</span>))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>闭包可以与函数指针互通</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RGB</span> = (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">color</span>(c: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB &#123;</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shwo</span>(c: <span class="title function_ invoke__">fn</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB) &#123; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">c</span>(<span class="string">&quot;black&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb</span> = color;</span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(rgb); <span class="comment">// (1, 1, 1)</span></span><br><span class="line">    <span class="comment">// 定义了实现`Fn(&amp;str) -&gt; RGB`trait 的闭包类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = | s: &amp;<span class="type">str</span> | &#123; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &#125;; <span class="comment">// 闭包</span></span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(c); <span class="comment">// (1, 2, 3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/blogimg/os/tuos/batch-os-detail.png.png" alt="batch-os-detail.png"></p><h3 id="Rust闭包的实现原理"><a href="#Rust闭包的实现原理" class="headerlink" title="Rust闭包的实现原理"></a>Rust闭包的实现原理</h3><h4 id="闭包的使用场景"><a href="#闭包的使用场景" class="headerlink" title="闭包的使用场景"></a>闭包的使用场景</h4><ol><li>未捕获环境变量(所有权)</li><li>捕获但修改环境变量(可变引用)</li><li>捕获但未修改环境变量(不可变引用)</li></ol><h4 id="未捕获环境变量"><a href="#未捕获环境变量" class="headerlink" title="未捕获环境变量"></a>未捕获环境变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 未捕获环境变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = || <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">c1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span><span class="comment">// #![feature(...)] 是一种属性，用于启用语言或标准库中的实验性功能</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span>&lt;T&gt; &#123;</span><br><span class="line">    env_var: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">### 标准库 FnOnce trait 的定义</span></span><br><span class="line"><span class="comment">pub trait FnOnce&lt;Args&gt; &#123;</span></span><br><span class="line"><span class="comment">type Output;</span></span><br><span class="line"><span class="comment">extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">FnOnce</span>&lt;()&gt; <span class="keyword">for</span> <span class="title class_">Closure</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">self</span>, args: ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Closure &#123; env_var: ()&#125;;</span><br><span class="line">    c.<span class="title function_ invoke__">call_once</span>(());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当你创建闭包的时候，编译器会解析你的闭包，然后生成一个匿名结构体<code>Closure</code>，其中的字段<code>env_var</code>用于存储捕获的自由变量；在上面的场景中闭包未捕获任何变量,所以<code>main</code>函数中创建<code>Closure</code>的字段值用<code>()</code>来表示；</p><p>接下来在为这个匿名的结构体<code>Closure</code>实现<code>FnOnce&lt;()&gt;</code>这个trait；其中<code>Arges</code>这个参数是闭包自身的参数，即闭包调用时传入的参数(捕获的环境变量)；</p><p>当闭包被调用的时候等价于调用匿名结构体实现的<code>call_once</code>这个方法；该方法会消耗掉该结构体的实例；</p></blockquote><p><strong>编译器将<code>FnOnce</code>类型的闭包看成是函数指针</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = || &#123; <span class="string">&quot;c1&quot;</span>; &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = || &#123; <span class="string">&quot;c2&quot;</span>; &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [c1, c2]; <span class="comment">// Ok</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="string">&quot;c3&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c3</span> = || &#123; i &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [c1, c2, c3] <span class="comment">// Error  expected fn pointer, found closure 他把c1, c2当成了函数指针，c3当成了闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="捕获但修改环境变量"><a href="#捕获但修改环境变量" class="headerlink" title="捕获但修改环境变量"></a>捕获但修改环境变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 可修改环境变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c2</span> = | i | &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">c2</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span><span class="comment">// #![feature(...)] 是一种属性，用于启用语言或标准库中的实验性功能</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    env_var: [<span class="type">i32</span>, <span class="number">3</span>],  <span class="comment">// 捕获的环境变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 至少需要一个能消耗自身的一个方法，用于在多次调用之间保持并修改状态。</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnOnce</span>&lt;(<span class="type">i32</span>, )&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">mut</span> <span class="keyword">self</span>, args: (<span class="type">i32</span>, )) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="keyword">self</span>.env_var[<span class="number">0</span>] = args.<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.env_var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">### 标准库 FnMut trait 的定义</span></span><br><span class="line"><span class="comment">pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; &#123;</span></span><br><span class="line"><span class="comment">type Output;</span></span><br><span class="line"><span class="comment">extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnMut</span>&lt;(<span class="type">i32</span>, )&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: (<span class="type">i32</span>, )) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">            <span class="keyword">self</span>.env_var[<span class="number">0</span>] = args.<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.env_var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = Closuse &#123; env_var: arr &#125;;</span><br><span class="line">    <span class="comment">// c.call_once((0, ));</span></span><br><span class="line">    c.<span class="title function_ invoke__">call_mut</span>((<span class="number">0</span>, ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="捕获但未修改环境变量"><a href="#捕获但未修改环境变量" class="headerlink" title="捕获但未修改环境变量"></a>捕获但未修改环境变量</h4><p>代码逻辑同上，多了一个Fn</p><h3 id="闭包的具体分类"><a href="#闭包的具体分类" class="headerlink" title="闭包的具体分类"></a>闭包的具体分类</h3>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现批处理系统</title>
      <link href="/OS/tuos/%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86/"/>
      <url>/OS/tuos/%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h1><p>管理无需或仅需少量用户交互即可运行的程序，在资源允许的情况下它可以自动安排程序的执行。</p><p>核心思想为：将多个程序打包到一起输入计算机。而当一个程序运行结束后，计算机会 <em>自动</em> 加载下一个程序到内存并开始执行。</p><h2 id="特权级机制"><a href="#特权级机制" class="headerlink" title="特权级机制"></a>特权级机制</h2><ul><li><p><em>保护</em> 计算机系统不受有意或无意出错的程序破坏的机制被称为 <strong>特权级</strong> (Privilege) 机制。</p><ul><li>应用程序不能执行某些可能破坏计算机系统的指令</li></ul></li><li><p>它让应用程序运行在<strong>用户态</strong>，而操作系统运行在<strong>内核态</strong>，且实现用户态和内核态的隔离。</p><ul><li>处理器设置两个不同安全等级的执行环境：<strong>用户态特权级的执行环境</strong>和<strong>内核态特权级的执行环境</strong>。且明确指出可能破坏计算机系统的内核态特权级指令子集，规定内核态特权级指令子集中的指令只能在内核态特权级的执行环境中执行。处理器在执行指令前会进行特权级安全检查，如果在用户态执行环境中执行这些内核态特权级指令，会产生异常。</li></ul></li><li><p>软硬件协同工作。</p></li></ul><h2 id="模拟客户端应用程序"><a href="#模拟客户端应用程序" class="headerlink" title="模拟客户端应用程序"></a>模拟客户端应用程序</h2><h3 id="创建应用端库"><a href="#创建应用端库" class="headerlink" title="创建应用端库"></a>创建应用端库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tuos/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new user -lib</span></span><br><span class="line">    Creating library `user` package</span><br><span class="line">note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br></pre></td></tr></table></figure><p>修改库名</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tuos/user/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;user_lib&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;Kay &lt;cn.kay.wang@gmail.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span> <span class="comment"># 这里要改不然后续执行会报错</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">riscv</span> = &#123; git = <span class="string">&quot;https://github.com/rcore-os/riscv&quot;</span>, features = [<span class="string">&quot;inline-asm&quot;</span>] &#125; </span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span> <span class="comment"># 因qemu9.0.0兼容性文件所以要设置</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <code>lib.rs</code> 中我们定义了用户库的入口点 <code>_start</code> </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性宏从指定库中导入到当前作用域中</span></span><br><span class="line"><span class="keyword">use</span> user_lib::println;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不修改符号名</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="comment">// 指定.text.entry段入口</span></span><br><span class="line"><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>());</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;unreachable after sys_exit!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还在 <code>lib.rs</code> 中看到了另一个 <code>main</code> </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标为弱链接，虽然名叫main但不会作为主函数</span></span><br><span class="line"><span class="meta">#[linkage = <span class="string">&quot;weak&quot;</span>]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Cannot find main!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了支持上述这些链接操作，我们需要在 <code>lib.rs</code> 的开头加入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="meta">#![feature(linkage)]</span></span><br></pre></td></tr></table></figure><h3 id="设置内存布局"><a href="#设置内存布局" class="headerlink" title="设置内存布局"></a>设置内存布局</h3><p>让操作系统能够把应用加载到内存地址，然后顺利启动并运行应用程序。</p><ul><li><p>在 <code>user/.cargo/config</code> 中，设置链接时使用链接脚本 <code>user/src/linker.ld</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user/.cargo/config</span></span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = &quot;riscv64gc-unknown-none-elf&quot;</span><br><span class="line"></span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    &quot;-Clink-args=-Tsrc/linker.ld&quot;, &quot;-Cforce-frame-pointers=yes&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>设置内存布局</p><ul><li>在<code>user/src/linker.ld</code>中设置程序起始地址为<code>0x80400000</code>；</li><li>将 <code>_start</code> 所在的 <code>.text.entry</code> 放在整个程序的开头，使得系统只要跳转到<code>0x80400000</code>就已经进入了 用户库的入口点，并会在初始化之后跳转到应用程序主逻辑；</li><li>提供了最终生成可执行文件的 <code>.bss</code> 段的起始和终止地址，方便 <code>clear_bss</code> 函数使用；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user/src/linker.ld</span></span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">BASE_ADDRESS = 0x80400000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        start_bss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">        end_bss = .;</span><br><span class="line">    &#125;</span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">        *(.debug*)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="调用系统ABI"><a href="#调用系统ABI" class="headerlink" title="调用系统ABI"></a>调用系统ABI</h3><p>使用RISC-V 提供的机器指令：执行环境调用指令（Execution Environment Call，简称 <code>ecall</code> ）和一类执行环境返回（Execution Environment Return，简称 <code>eret</code> ）指令。其中：</p><ul><li><code>ecall</code> 具有用户态到内核态的执行环境切换能力的函数调用指令；</li><li><code>sret</code> ：具有内核态到用户态的执行环境切换能力的函数返回指令。</li></ul><p>这里约定如下两个系统调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 功能：将内存中缓冲区中的数据写入文件。</span></span><br><span class="line"><span class="comment">/// 参数：`fd` 表示待写入文件的文件描述符；</span></span><br><span class="line"><span class="comment">///      `buf` 表示内存中缓冲区的起始地址；</span></span><br><span class="line"><span class="comment">///      `len` 表示内存中缓冲区的长度。</span></span><br><span class="line"><span class="comment">/// 返回值：返回成功写入的长度。</span></span><br><span class="line"><span class="comment">/// syscall ID：64</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buf: *<span class="keyword">const</span> <span class="type">u8</span>, len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：退出应用程序并将返回值告知批处理系统。</span></span><br><span class="line"><span class="comment">/// 参数：`exit_code` 表示应用程序的返回值。</span></span><br><span class="line"><span class="comment">/// 返回值：该系统调用不应该返回。</span></span><br><span class="line"><span class="comment">/// syscall ID：93</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_exit</span>(exit_code: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> !;</span><br></pre></td></tr></table></figure><p>由于rust不直接支持寄存器操作，为此我们需要在代码中使用内嵌汇编来完成参数&#x2F;返回值绑定和 <code>ecall</code> 指令的插入：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::arch::asm;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>: <span class="type">isize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// asm! 宏可以将汇编代码嵌入到局部的函数上下文中。</span></span><br><span class="line">        <span class="comment">// 相比 global_asm!, asm! 宏可以获取上下文中的变量信息并允许嵌入的汇编代码对这些变量进行操作</span></span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有的系统调用都封装成 <code>syscall</code> 函数。</p><blockquote><p>在 RISC-V 调用规范中，和函数调用的 ABI 情形类似，约定寄存器 <code>a0~a6</code> 保存系统调用的参数， <code>a0</code> 保存系统调用的返回值。有些许不同的是寄存器 <code>a7</code> 用来传递 syscall ID，这是因为所有的 syscall 都是通过 <code>ecall</code> 指令触发的，除了各输入参数之外我们还额外需要一个寄存器来保存要请求哪个系统调用。</p><p><strong>RISC-V 寄存器编号和别名</strong></p><p>RISC-V 寄存器编号从 <code>0~31</code> ，表示为 <code>x0~x31</code> 。 其中：</p><ul><li><code>x10~x17</code> : 对应 <code>a0~a7</code></li><li><code>x1</code> ：对应 <code>ra</code></li></ul><p>在 <code>ecall</code> 指令中<code>a0~a2</code> 和 <code>a7</code> 作为输入寄存器分别表示系统调用参数和系统调用 ID，当系统调用返回后， <code>a0</code> 作为输出寄存器保存系统调用的返回值。</p></blockquote><p>于是 <code>sys_write</code> 和 <code>sys_exit</code> 只需将 <code>syscall</code> 进行包装：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buffer: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_WRITE, [fd, buffer.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, buffer.<span class="title function_ invoke__">len</span>()])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述两个系统调用在用户库 <code>user_lib</code> 中进一步封装，从而更加接近在 Linux 等平台的实际系统调用接口：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> syscall::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(fd: <span class="type">usize</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_write</span>(fd, buf) &#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_exit</span>(exit_code) &#125;</span><br></pre></td></tr></table></figure><p>将 <code>console</code> 子模块中 <code>Stdout::write_str</code> 改成基于 <code>write</code> 的实现，且传入的 <code>fd</code> 参数设置为 1，它代表标准输出， 也就是输出到屏幕。目前我们不需要考虑其他的 <code>fd</code> 选取情况。这样，应用程序的 <code>println!</code> 宏借助系统调用变得可用了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/src/console.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STDOUT: <span class="type">usize</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">write</span>(STDOUT, s.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exit</code> 接口则在用户库中的 <code>_start</code> 内使用，当应用程序主逻辑 <code>main</code> 返回之后，使用它退出应用程序并将返回值告知 底层的批处理系统。</p><h3 id="模拟应用程序执行"><a href="#模拟应用程序执行" class="headerlink" title="模拟应用程序执行"></a>模拟应用程序执行</h3><p>尝试在用户态模拟器 <code>qemu-riscv64</code> 执行这两个应用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> user</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> target/riscv64gc-unknown-none-elf/release/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认待执行的应用为 ELF 格式</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file 03priv_inst</span></span><br><span class="line">03priv_inst: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, not stripped</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行特权指令出错</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 ./03priv_inst</span></span><br><span class="line">Try to execute privileged instruction in U Mode</span><br><span class="line">Kernel should kill this application!</span><br><span class="line">Illegal instruction (core dumped)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行访问特权级 CSR 的指令出错</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 ./04priv_csr</span></span><br><span class="line">Try to access privileged CSR in U Mode</span><br><span class="line">Kernel should kill this application!</span><br><span class="line">Illegal instruction (core dumped)</span><br></pre></td></tr></table></figure><blockquote><p>在<code>user/Cargo.toml</code>下要设置</p><p>[package]</p><p>edition &#x3D; “2018”</p><p>[profile.release]</p><p>5 1  0opt-level &#x3D; 0</p><p>不然几个实例客户端程序将可能会出错</p></blockquote><h2 id="实现批处理系统"><a href="#实现批处理系统" class="headerlink" title="实现批处理系统"></a>实现批处理系统</h2><ul><li>操作系统自身运行在内核态，支持应用程序在用户态运行，且能够完成应用程序发出的系统调用。</li><li>能够一个接着一个地自动运行不同的运行程序</li></ul><p>在具体实现其批处理执行应用程序功能之前，本节我们首先实现该应用加载机制，也即：在操作系统和应用程序需要被放置到同一个可执行文件的前提下，设计一种尽量简洁的应用放置和加载方式，使得操作系统容易找到应用被放置到的位置，从而在批处理操作系统和应用程序之间建立起联系的纽带。具体而言，应用放置采用“静态绑定”的方式，而操作系统加载应用则采用“动态加载”的方式：</p><ul><li>静态绑定：通过一定的编程技巧，把多个应用程序代码和批处理操作系统代码“绑定”在一起。</li><li>动态加载：基于静态编码留下的“绑定”信息，操作系统可以找到每个应用程序文件二进制代码的起始地址和长度，并能加载到内存中运行。</li></ul><h3 id="将应用程序链接到内核"><a href="#将应用程序链接到内核" class="headerlink" title="将应用程序链接到内核"></a>将应用程序链接到内核</h3><p>利用<code>build.rs</code>脚本文件生成汇编代码将应用程序链接到内核</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/build.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fs::&#123;read_dir, File&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="type">Result</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=../user/src/&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=&#123;&#125;&quot;</span>, TARGET_PATH);</span><br><span class="line">    <span class="title function_ invoke__">insert_app_data</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> TARGET_PATH: &amp;<span class="type">str</span> = <span class="string">&quot;../user/target/riscv64gc-unknown-none-elf/release/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">insert_app_data</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;src/link_app.S&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">apps</span>: <span class="type">Vec</span>&lt;_&gt; = <span class="title function_ invoke__">read_dir</span>(<span class="string">&quot;../user/src/bin&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|dir_entry| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">name_with_ext</span> = dir_entry.<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">file_name</span>().<span class="title function_ invoke__">into_string</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            name_with_ext.<span class="title function_ invoke__">drain</span>(name_with_ext.<span class="title function_ invoke__">find</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">unwrap</span>()..name_with_ext.<span class="title function_ invoke__">len</span>());</span><br><span class="line">            name_with_ext</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    apps.<span class="title function_ invoke__">sort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">writeln!</span>(</span><br><span class="line">        f,</span><br><span class="line">        <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">    .align 3</span></span><br><span class="line"><span class="string">    .section .data</span></span><br><span class="line"><span class="string">    .global _num_app</span></span><br><span class="line"><span class="string">_num_app:</span></span><br><span class="line"><span class="string">    .quad &#123;&#125;&quot;#</span>,</span><br><span class="line">        apps.<span class="title function_ invoke__">len</span>()</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..apps.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">r#&quot;    .quad app_&#123;&#125;_start&quot;#</span>, i)?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln!</span>(f, <span class="string">r#&quot;    .quad app_&#123;&#125;_end&quot;#</span>, apps.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx, app) <span class="keyword">in</span> apps.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;app_&#123;&#125;: &#123;&#125;&quot;</span>, idx, app);</span><br><span class="line">        <span class="built_in">writeln!</span>(</span><br><span class="line">            f,</span><br><span class="line">            <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">    .section .data</span></span><br><span class="line"><span class="string">    .global app_&#123;0&#125;_start</span></span><br><span class="line"><span class="string">    .global app_&#123;0&#125;_end</span></span><br><span class="line"><span class="string">app_&#123;0&#125;_start:</span></span><br><span class="line"><span class="string">    .incbin &quot;&#123;2&#125;&#123;1&#125;.bin&quot;</span></span><br><span class="line"><span class="string">app_&#123;0&#125;_end:&quot;#</span>,</span><br><span class="line">            idx, app, TARGET_PATH</span><br><span class="line">        )?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>build.rs</code>脚本文件将生成以下类似文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># os/src/link_app.S</span><br><span class="line"></span><br><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line">_num_app:</span><br><span class="line">    .quad 5</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_2_start</span><br><span class="line">    .quad app_3_start</span><br><span class="line">    .quad app_4_start</span><br><span class="line">    .quad app_4_end</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">app_0_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin&quot;</span><br><span class="line">app_0_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_1_start</span><br><span class="line">    .global app_1_end</span><br><span class="line">app_1_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin&quot;</span><br><span class="line">app_1_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_2_start</span><br><span class="line">    .global app_2_end</span><br><span class="line">app_2_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/02power.bin&quot;</span><br><span class="line">app_2_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_3_start</span><br><span class="line">    .global app_3_end</span><br><span class="line">app_3_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/03priv_inst.bin&quot;</span><br><span class="line">app_3_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_4_start</span><br><span class="line">    .global app_4_end</span><br><span class="line">app_4_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/04priv_csr.bin&quot;</span><br><span class="line">app_4_end:</span><br></pre></td></tr></table></figure><p>将汇编代码链接到内核</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;link_app.S&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="找到并加载应用程序二进制码"><a href="#找到并加载应用程序二进制码" class="headerlink" title="找到并加载应用程序二进制码"></a>找到并加载应用程序二进制码</h3><p>创建一个<em>应用管理器</em><code>AppManager</code>用来找到找到并加载应用程序二进制码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppManager</span> &#123;</span><br><span class="line">    num_app: <span class="type">usize</span>,</span><br><span class="line">    current_app: <span class="type">usize</span>,</span><br><span class="line">    app_start: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中：</p><ul><li><code>current_app</code> 字段表示当前执行的是第几个应用，它是一个可修改的变量，会在系统运行期间发生变化。</li><li></li></ul></blockquote><p>9 崽子？</p><p>0 说的有道理</p><h3 id="实现跨特权级的系统接口调用"><a href="#实现跨特权级的系统接口调用" class="headerlink" title="实现跨特权级的系统接口调用"></a>实现跨特权级的系统接口调用</h3><h3 id="执行系统调用前后能够准备和恢复用户态执行应用程序的上下文"><a href="#执行系统调用前后能够准备和恢复用户态执行应用程序的上下文" class="headerlink" title="执行系统调用前后能够准备和恢复用户态执行应用程序的上下文"></a>执行系统调用前后能够准备和恢复用户态执行应用程序的上下文</h3><h3 id="支持多个应用程序轮流启动运行"><a href="#支持多个应用程序轮流启动运行" class="headerlink" title="支持多个应用程序轮流启动运行"></a>支持多个应用程序轮流启动运行</h3><h2 id="二者之间的特权级切换"><a href="#二者之间的特权级切换" class="headerlink" title="二者之间的特权级切换"></a>二者之间的特权级切换</h2><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用程序与基本执行环境</title>
      <link href="/OS/tuos/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
      <url>/OS/tuos/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="应用程序与基本执行环境"><a href="#应用程序与基本执行环境" class="headerlink" title="应用程序与基本执行环境"></a>应用程序与基本执行环境</h1><h2 id="创建一个bin项目"><a href="#创建一个bin项目" class="headerlink" title="创建一个bin项目"></a>创建一个bin项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> tuos</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> tuos</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new os --bin</span></span><br><span class="line">    Creating binary (application) `os` package</span><br><span class="line">note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br></pre></td></tr></table></figure><h2 id="移除执行环境对操作系统的依赖"><a href="#移除执行环境对操作系统的依赖" class="headerlink" title="移除执行环境对操作系统的依赖"></a>移除执行环境对操作系统的依赖</h2><h3 id="1-添加目标平台"><a href="#1-添加目标平台" class="headerlink" title="1.添加目标平台"></a>1.添加目标平台</h3><ol><li>我们要构建一个可以在裸机上运行的 RISC-V架构的操作系统，那么就需要添加对目标平台的支持：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tuos/os</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target add riscv64gc-unknown-none-elf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version --verbose</span></span><br><span class="line">rustc 1.79.0-nightly (385fa9d84 2024-04-04)</span><br><span class="line">binary: rustc</span><br><span class="line">commit-hash: 385fa9d845dd326c6bbfd58c22244215e431948a</span><br><span class="line">commit-date: 2024-04-04</span><br><span class="line">host: x86_64-unknown-linux-gnu</span><br><span class="line">release: 1.79.0-nightly</span><br><span class="line">LLVM version: 18.1.2</span><br></pre></td></tr></table></figure><p>这条命令有几个作用：</p><ol><li><p><strong>识别目标平台：</strong></p><ul><li><code>riscv64gc</code> 表示 RISC-V 64位通用计算（General-Purpose Computing）架构（ CPU 架构）。</li><li><code>unknown</code> 表示 Rust 不了解这个目标的操作系统或供应商信息（CPU 厂商）。</li><li><code>none</code> 表示没有操作系统，这通常用于裸机编程（操作系统）。</li><li><code>elf</code> 表示没有标准的运行时库（没有任何系统调用的封装支持），但可以生成 ELF 格式的执行程序（运行时库）。</li></ul></li><li><p><strong>安装必要组件：</strong>如果 <code>rustup</code> 有为 <code>riscv64gc-unknown-none-elf</code> 准备的预编译组件，它会尝试下载并安装这些组件。</p></li><li><p><strong>更新Rust工具链配置：</strong>在 Rust 配置中添加对新目标的支持，这样当你使用 <code>cargo build --target riscv64gc-unknown-none-elf</code> 命令时，Cargo 就会知道如何为 <code>riscv64gc-unknown-none-elf</code> 目标构建你的项目。</p></li></ol><p>可以使用如下命令查看当前Rust工具链支持的所有目标平台:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target list</span></span><br></pre></td></tr></table></figure><p>2.在 <code>tuos</code> 目录下新建 <code>.cargo</code> 目录，并在这个目录下创建 <code>config</code> 文件，并在里面输入如下内容：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#  tuos/os/.cargo/config</span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br></pre></td></tr></table></figure><p>这会对于 Cargo 工具在 os 目录下的行为进行调整：<strong>现在默认会使用 riscv64gc 作为目标平台而不是原先的默认 x86_64-unknown-linux-gnu。</strong></p><h3 id="2-移除标准库依赖"><a href="#2-移除标准库依赖" class="headerlink" title="2.移除标准库依赖"></a>2.移除标准库依赖</h3><p>我们希望它能够被编译到 RV64GC 裸机平台上，为此我们需要移除它对于 Rust std标准库的依赖，因为 Rust std标准库自己就需要操作系统内核的支持。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># tuos/os/src/main.rs</span><br><span class="line"><span class="comment">// 告诉 Rust 编译器不使用 Rust 标准库 std 转而使用核心库 core（core库不需要操作系统的支持）;</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 注释掉println!宏,它是由标准库 std 提供的且会使用到一个名为 write 的系统调用;</span></span><br></pre></td></tr></table></figure><h3 id="3-添加错误处理机制"><a href="#3-添加错误处理机制" class="headerlink" title="3.添加错误处理机制"></a>3.添加错误处理机制</h3><p>Rust编译器在编译程序时，从安全性考虑，需要有 <code>panic!</code> 宏的具体实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># os/src/lang_items.rs</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"><span class="comment">// 指定一个函数作为程序的 panic 处理程序。</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在把 <code>panic_handler</code> 配置在单独的文件 <code>tuos/src/lang_items.rs</code> 后，需要在os&#x2F;src&#x2F;main.rs文件中添加以下内容才能正常编译整个软件：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标准库(std)依赖</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入外部模块，内容为对panic!的具体实现</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br></pre></td></tr></table></figure><h3 id="4-移除标准main函数"><a href="#4-移除标准main函数" class="headerlink" title="4.移除标准main函数"></a>4.移除标准main函数</h3><p>应用程序在执行之前进行一些初始化工作，然后才跳转到应用程序的入口点（也就是跳转到我们编写的 <code>main</code> 函数）开始执行。 <code>start</code> 语义项代表了标准库 std 在执行应用程序之前需要进行的一些初始化工作。由于我们禁用了标准库，编译器也就找不到这项功能的实现了。最简单的解决方案就是压根不让编译器使用这项功能。我们在 <code>main.rs</code> 的开头加入设置 <code>#![no_main]</code> 告诉编译器我们没有一般意义上的 <code>main</code> 函数，并将原来的 <code>main</code> 函数删除。在失去了 <code>main</code> 函数的情况下，编译器也就不需要完成所谓的初始化工作了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标准库(std)依赖</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 禁用标准main函数</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="comment">// 导入外部模块，内容为对panic!的具体实现</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="comment">// 删掉 自带的main函数</span></span><br></pre></td></tr></table></figure><p>至此，我们成功移除了标准库的依赖，并完成了构建裸机平台上操作系统的第一步工作–通过编译器检查并生成执行码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">warning: `/home/kay/workspace/tuos/os/.cargo/config` is deprecated in favor of `config.toml`</span><br><span class="line">note: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`</span><br><span class="line">   Compiling os v0.1.0 (/home/kay/workspace/tuos/os)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.06s</span><br></pre></td></tr></table></figure><h2 id="验证Qemu模拟器与执行环境是否正确可用"><a href="#验证Qemu模拟器与执行环境是否正确可用" class="headerlink" title="验证Qemu模拟器与执行环境是否正确可用"></a>验证Qemu模拟器与执行环境是否正确可用</h2><p>下面我们将实践在 Qemu 上执行内核的第一条指令,用以检验环境是否正确可用。</p><h3 id="编写内核第一条指令"><a href="#编写内核第一条指令" class="headerlink" title="编写内核第一条指令"></a>编写内核第一条指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/entry.asm</span></span><br><span class="line">    .section .text.entry # .section: 定义或切换到一个特定的代码段 .text.enery代码段</span><br><span class="line">    .globl _start        # 告知编译器 _start 是一个全局符号,可以被其他目标文件使用</span><br><span class="line">_start:                  # 全局符号,指向下面的(li x1, 100)</span><br><span class="line">    li x1, 100           # 立即数 100 被加载到了寄存器 x1 中</span><br></pre></td></tr></table></figure><p>一般情况下，所有的代码都被放到一个名为 <code>.text</code> 的代码段中，这里我们将其命名为 <code>.text.entry</code> 从而区别于其他 <code>.text</code> 的目的在于我们想要确保该段被放置在相比任何其他代码段更低的地址上。这样，作为内核的入口点，这段指令才能被最先执行。</p><blockquote><p> 常见的 x86、RISC-V 等架构采用的是小端序。</p></blockquote><p><strong>将汇编代码嵌入<code>main.rs</code>：</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"><span class="comment">// 移除标准库</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 移除main函数</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="comment">// 载入模块</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="comment">// 引用模块</span></span><br><span class="line"><span class="keyword">use</span> core::arch::global_asm;</span><br><span class="line"><span class="comment">// global_asm!宏：嵌入全局汇编代码;include_str!宏：文件的内容作为一个字符串嵌入到程序中;</span></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p><strong>关于 <code>main</code> 函数和 <code>global_asm!</code> 的执行顺序，重要的是理解它们的作用和上下文：</strong></p><ul><li><p><strong>global_asm!</strong>: 这个宏用于在编译时嵌入汇编代码。这些汇编代码通常用于设置中断向量表、初始化硬件或其他低级设置。这些代码在二进制文件的开始或特定段中，并且在程序开始执行时就已经存在。<em>它们并不是在运行时执行的代码，而是作为二进制文件的一部分存在</em>。</p></li><li><p><strong>main 函数</strong>: 在 Rust 程序中，<code>main</code> 函数是程序的入口点。当程序开始执行时，它首先会跳转到 <code>main</code> 函数。<em>在 <code>main</code> 函数之前，任何全局的初始化代码（包括通过 <code>global_asm!</code> 嵌入的汇编代码）都应该已经完成</em>。</p></li></ul></blockquote><h3 id="调整内核的内存布局"><a href="#调整内核的内存布局" class="headerlink" title="调整内核的内存布局"></a>调整内核的内存布局</h3><p>由于链接器默认的内存布局并不能符合我们的要求，为了实现与 Qemu 正确对接，我们可以通过 <strong>链接脚本</strong> (Linker Script) 调整链接器的行为，使得最终生成的可执行文件的内存布局符合Qemu的预期，即内核第一条指令的地址应该位于 0x80200000 。我们修改 Cargo 的配置文件来使用我们自己的链接脚本 <code>os/src/linker.ld</code> 而非使用默认的内存布局：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/.cargo/config</span></span><br><span class="line">[build]</span><br><span class="line">target = &quot;riscv64gc-unknown-none-elf&quot;</span><br><span class="line"></span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    &quot;-Clink-arg=-Tsrc/linker.ld&quot;, &quot;-Cforce-frame-pointers=yes&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><ul><li>“-Clink-arg&#x3D;-Tsrc&#x2F;linker.ld” ：告诉 Rust 编译器在链接阶段使用 <code>src/linker.ld</code> 作为链接器脚本</li><li>“-Cforce-frame-pointers&#x3D;yes” : 强制编译器在生成的代码中包含帧指针。</li></ul></blockquote><p>链接脚本 <code>os/src/linker.ld</code> 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)# 设置了目标平台为 riscv;</span><br><span class="line">ENTRY(_start)# 设置了整个程序的入口点为之前定义的全局符号 _start;</span><br><span class="line">BASE_ADDRESS = 0x80200000;# 定义了一个常量 BASE_ADDRESS 为 0x80200000 ,内核的初始化时的地址;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 1 行我们设置了目标平台为 riscv ；第 2 行我们设置了整个程序的入口点为之前定义的全局符号 <code>_start</code>；</p><p>第 3 行定义了一个常量 <code>BASE_ADDRESS</code> 为 <code>0x80200000</code> ，也就是我们之前提到内核的初始化代码被放置的地址；</p><p>从第 5 行开始体现了链接过程中对输入的目标文件的段的合并。其中 <code>.</code> 表示当前地址，也就是链接器会从它指向的位置开始往下放置从输入的目标文件中收集来的段。我们可以对 <code>.</code> 进行赋值来调整接下来的段放在哪里，也可以创建一些全局符号赋值为 <code>.</code> 从而记录这一时刻的位置。我们还能够看到这样的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rodata : &#123;</span><br><span class="line">    *(.rodata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒号前面表示最终生成的可执行文件的一个段的名字，花括号内按照放置顺序描述将所有输入目标文件的哪些段放在这个段中，每一行格式为 <code>&lt;ObjectFile&gt;(SectionName)</code>，表示目标文件 <code>ObjectFile</code> 的名为 <code>SectionName</code> 的段需要被放进去。我们也可以使用通配符来书写 <code>&lt;ObjectFile&gt;</code> 和 <code>&lt;SectionName&gt;</code> 分别表示可能的输入目标文件和段名。因此，最终的合并结果是，在最终可执行文件中各个常见的段 <code>.text, .rodata .data, .bss</code> 从低地址到高地址按顺序放置，每个段里面都包括了所有输入目标文件的同名段，且每个段都有两个全局符号给出了它的开始和结束地址（比如 <code>.text</code> 段的开始和结束地址分别是 <code>stext</code> 和 <code>etext</code> ）。</p><p>第 12 行我们将包含内核第一条指令的 <code>.text.entry</code> 段放在最终的 <code>.text</code> 段的最开头，同时注意到在最终内存布局中代码段 <code>.text</code> 又是先于任何其他段的。因为所有的段都从 <code>BASE_ADDRESS</code> 也即 <code>0x80200000</code> 开始放置，这就能够保证内核的第一条指令正好放在 <code>0x80200000</code> 从而能够正确对接到 Qemu 上。</p><p>生成内核可执行文件，切换到 <code>os</code> 目录下进行以下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以 release 模式生成了内核可执行文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --release</span></span><br><span class="line">warning: `/home/kay/workspace/tuos/os/.cargo/config` is deprecated in favor of `config.toml`</span><br><span class="line">note: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`</span><br><span class="line">   Compiling os v0.1.0 (/home/kay/workspace/tuos/os)</span><br><span class="line">    Finished `release` profile [optimized] target(s) in 0.06s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 file 工具查看它的属性</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file target/riscv64gc-unknown-none-elf/release/os</span></span><br><span class="line">target/riscv64gc-unknown-none-elf/release/os: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure><h3 id="手动加载内核可执行文件"><a href="#手动加载内核可执行文件" class="headerlink" title="手动加载内核可执行文件"></a>手动加载内核可执行文件</h3><p>使用如下命令可以丢弃内核可执行文件中的元数据得到内核镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cargo build --release</code>后得到的内核可执行文件完全符合我们对于内存布局的要求，但是我们不能将其直接提交给 Qemu ，因为它除了实际会被用到的代码和数据段之外还有一些多余的元数据，这些元数据无法被 Qemu 在加载文件时利用，且会使代码和数据段被加载到错误的位置。所以我们需要将其元数据丢弃</p></blockquote><h3 id="基于GDB验证启动流程"><a href="#基于GDB验证启动流程" class="headerlink" title="基于GDB验证启动流程"></a>基于GDB验证启动流程</h3><p>在 <code>os</code> 目录下通过以下命令启动 Qemu 并加载 RustSBI 和内核镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">    -machine virt \</span></span><br><span class="line"><span class="language-bash">    -nographic \</span></span><br><span class="line"><span class="language-bash">    -bios ../bootloader/rustsbi-qemu.bin \</span></span><br><span class="line"><span class="language-bash">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \</span></span><br><span class="line"><span class="language-bash">    -s -S</span></span><br></pre></td></tr></table></figure><p><code>-s</code> 可以使 Qemu 监听本地 TCP 端口 1234 等待 GDB 客户端连接，而 <code>-S</code> 可以使 Qemu 在收到 GDB 的请求后再开始运行。因此，Qemu 暂时没有任何输出。注意，如果不想通过 GDB 对于 Qemu 进行调试而是直接运行 Qemu 的话，则要删掉最后一行的 <code>-s -S</code> 。</p><p>打开另一个终端，启动一个 GDB 客户端连接到 Qemu ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-elf-gdb \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;file target/riscv64gc-unknown-none-elf/release/os&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;set arch riscv:rv64&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;target remote localhost:1234&#x27;</span></span></span><br><span class="line">[GDB output]</span><br><span class="line">0x0000000000001000 in ?? ()</span><br></pre></td></tr></table></figure><p>可以看到，正如我们在上一节提到的那样，Qemu 启动后 PC 被初始化为 <code>0x1000</code> 。我们可以检查一下 Qemu 的启动固件的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) x/10i <span class="variable">$pc</span></span></span><br><span class="line">=&gt; 0x1000:      auipc   t0,0x0</span><br><span class="line">   0x1004:      add     a2,t0,40</span><br><span class="line">   0x1008:      csrr    a0,mhartid</span><br><span class="line">   0x100c:      ld      a1,32(t0)</span><br><span class="line">   0x1010:      ld      t0,24(t0)</span><br><span class="line">   0x1014:      jr      t0</span><br><span class="line">   0x1018:      unimp</span><br><span class="line">   0x101a:      .2byte  0x8000</span><br><span class="line">   0x101c:      unimp</span><br><span class="line">   0x101e:      unimp</span><br></pre></td></tr></table></figure><p>这里 <code>x/10i $pc</code> 的含义是从当前 PC 值的位置开始，在内存中反汇编 10 条指令。不过可以看到 Qemu 的固件仅包含 5 条指令，从 <code>0x1018</code> 开始都是数据，当数据为 0 的时候则会被反汇编为 <code>unimp</code> 指令。 <code>0x101a</code> 处的数据 <code>0x8000</code> 是能够跳转到 <code>0x80000000</code> 进入启动下一阶段的关键。总之，在执行位于 <code>0x1014</code> 的指令之前，寄存器 <code>t0</code> 的值恰好为 <code>0x80000000</code> ，随后通过 <code>jr t0</code> 便可以跳转到该地址。我们可以通过单步调试来复盘这个过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001008 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000000000100c in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001010 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001010 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/x <span class="variable">$t0</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0x80000000</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000000 in ?? ()</span><br></pre></td></tr></table></figure><p>其中， <code>si</code> 可以让 Qemu 每次向下执行一条指令，之后屏幕会打印出待执行的下一条指令的地址。 <code>p/x $t0</code> 以 16 进制打印寄存器 <code>t0</code> 的值，注意当我们要打印寄存器的时候需要在寄存器的名字前面加上 <code>$</code> 。可以看到，当位于 <code>0x1010</code> 的指令执行完毕后，下一条待执行的指令位于 RustSBI 的入口，也即 <code>0x80000000</code> ，这意味着我们即将把控制权转交给 RustSBI 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/10i $pc</span><br><span class="line">=&gt; 0x80000000:  auipc   sp,0x29</span><br><span class="line">   0x80000004:  add     sp,sp,-200</span><br><span class="line">   0x80000008:  lui     t0,0x4</span><br><span class="line">   0x8000000a:  add     t1,a0,1</span><br><span class="line">   0x8000000e:  add     sp,sp,t0</span><br><span class="line">   0x80000010:  add     t1,t1,-1</span><br><span class="line">   0x80000012:  bnez    t1,0x8000000e</span><br><span class="line">   0x80000016:  j       0x80015e0c</span><br><span class="line">   0x8000001a:  unimp</span><br><span class="line">   0x8000001c:  add     sp,sp,-32</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000008 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000008000000a in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000008000000e in ?? ()</span><br></pre></td></tr></table></figure><p>我们可以用同样的方式反汇编 RustSBI 最初的几条指令并单步调试。不过由于 RustSBI 超出了本书的范围，我们这里并不打算进行深入。接下来我们检查控制权能否被移交给我们的内核：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) b *0x80200000</span></span><br><span class="line">Breakpoint 1 at 0x80200000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) c</span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000080200000 in ?? ()</span><br></pre></td></tr></table></figure><p>我们在内核的入口点，也即地址 <code>0x80200000</code> 处打一个断点。需要注意，当需要在一个特定的地址打断点时，需要在地址前面加上 <code>*</code> 。接下来通过 <code>c</code> 命令（Continue 的缩写）让 Qemu 向下运行直到遇到一个断点。可以看到，我们成功停在了 <code>0x80200000</code> 处。随后，可以检查内核第一条指令是否被正确执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/5i $pc</span><br><span class="line">=&gt; 0x80200000:  li      ra,100</span><br><span class="line">   0x80200004:  unimp</span><br><span class="line">   0x80200006:  unimp</span><br><span class="line">   0x80200008:  unimp</span><br><span class="line">   0x8020000a:  unimp</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080200004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/d <span class="variable">$x1</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 100</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/x <span class="variable">$sp</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 0x0</span></span><br></pre></td></tr></table></figure><p>可以看到我们在 <code>entry.asm</code> 中编写的第一条指令可以在 <code>0x80200000</code> 处找到。这里 <code>ra</code> 是寄存器 <code>x1</code> 的别名， <code>p/d $x1</code> 可以以十进制打印寄存器 <code>x1</code> 的值，它的结果正确。最后，作为下一节的铺垫，我们可以检查此时栈指针 <code>sp</code> 的值，可以发现它目前是 0 。下一节我们将设置好栈空间，使得内核代码可以正常进行函数调用，随后将控制权转交给 Rust 代码。</p><h2 id="设置栈空间以及内核初始化"><a href="#设置栈空间以及内核初始化" class="headerlink" title="设置栈空间以及内核初始化"></a>设置栈空间以及内核初始化</h2><h3 id="分配栈空间"><a href="#分配栈空间" class="headerlink" title="分配栈空间"></a>分配栈空间</h3><p>我们在 <code>entry.asm</code> 中分配启动栈空间，并在控制权被转交给 Rust 入口之前将栈指针 <code>sp</code> 设置为栈顶的位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/entry.asm</span></span><br><span class="line"></span><br><span class="line">    .section .text.entry# 定义一个段</span><br><span class="line">    .globl _start# 定义一个全局符号</span><br><span class="line">_start:# 程序入口</span><br><span class="line">    la sp, boot_stack_top# 立即将 boot_stack_top 的地址加载到栈指针 sp 中</span><br><span class="line">    call main # 调用一个名为main的子程序</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16# 为数据段分配一定数量的空间。</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:# 表示为栈顶 ,上文_start程序入口加载的位置</span><br></pre></td></tr></table></figure><blockquote><p>综上所述，这段代码定义了程序的入口点 <code>_start</code>，并设置了一个栈空间，栈的顶部是 <code>boot_stack_top</code>，底部是 <code>boot_stack_lower_bound</code>，总共 64KB。程序从 <code>_start</code> 开始执行，首先设置栈指针，然后调用 Rust 编写的 <code>main</code> 函数。</p></blockquote><h3 id="编写入口函数"><a href="#编写入口函数" class="headerlink" title="编写入口函数"></a>编写入口函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要对该函数名进行修饰，以便其他语言就可以通过该原始名称来链接和调用 Rust 函数或访问 Rust 变量。</span></span><br><span class="line"><span class="comment">// 这里面的main名字要与汇编代码中指定的入口子函数名称一致</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> ! &#123; </span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对-bss-段的清零"><a href="#对-bss-段的清零" class="headerlink" title="对 .bss 段的清零"></a>对 <code>.bss</code> 段的清零</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对.bss段清零</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">clear_bss</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    (sbss <span class="keyword">as</span> <span class="type">usize</span>..ebss <span class="keyword">as</span> <span class="type">usize</span>).for_each(|a| &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在函数 <code>clear_bss</code> 中，我们会尝试从其他地方找到全局符号 <code>sbss</code> 和 <code>ebss</code> ，它们由链接脚本 <code>linker.ld</code> 给出，并分别指出需要被清零的 <code>.bss</code> 段的起始和终止地址。接下来我们只需遍历该地址区间并逐字节进行清零即可。</p></blockquote><h2 id="使用RustSBI-实现字符打印功能"><a href="#使用RustSBI-实现字符打印功能" class="headerlink" title="使用RustSBI 实现字符打印功能"></a>使用RustSBI 实现字符打印功能</h2><p>RustSBI 通过实现 SBI 标准，使得操作系统能够利用RISC-V处理器的指令集系统来执行各种操作。</p><h3 id="调用-SBI-服务"><a href="#调用-SBI-服务" class="headerlink" title="调用 SBI 服务"></a>调用 SBI 服务</h3><p><strong>在 <code>Cargo.toml</code> 中引入 sbi_rt 依赖来调用 SBI 服务的接口：</strong></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># os/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span> <span class="comment"># 因为兼容问题Qemu9.0.0在进行后续学习时候或出错，故将版次改为 2018</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">sbi-rt</span> = &#123; version = <span class="string">&quot;0.0.2&quot;</span>, features = [<span class="string">&quot;legacy&quot;</span>] &#125;</span><br></pre></td></tr></table></figure><p>我们将内核与 RustSBI 通信的相关功能实现在子模块 <code>sbi</code> 中，因此我们需要在 <code>main.rs</code> 中加入 <code>mod sbi</code> 将该子模块加入我们的项目。在 <code>os/src/sbi.rs</code> 中，我们直接调用 sbi_rt 提供的接口来将输出字符：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"><span class="keyword">mod</span> sbi;</span><br><span class="line"></span><br><span class="line"># os/src/sbi.rs</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">console_putchar</span>(c: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="comment">// #[allow(deprecated)]属性来禁止编译器发出警告,对于某些已经弃用的方法。</span></span><br><span class="line">    <span class="meta">#[allow(deprecated)]</span></span><br><span class="line">    sbi_rt::legacy::<span class="title function_ invoke__">console_putchar</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现关机功能"><a href="#实现关机功能" class="headerlink" title="实现关机功能"></a>实现关机功能</h3><p><strong>实现关机功能：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/sbi.rs</span></span><br><span class="line">pub fn shutdown(failure: bool) -&gt; ! &#123;</span><br><span class="line">    use sbi_rt::&#123;system_reset, NoReason, Shutdown, SystemFailure&#125;;</span><br><span class="line">    if !failure &#123;</span><br><span class="line">        system_reset(Shutdown, NoReason);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        system_reset(Shutdown, SystemFailure);</span><br><span class="line">    &#125;</span><br><span class="line">    unreachable!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">mod</span> console;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/console.rs</span></span><br><span class="line"><span class="keyword">use</span> crate::sbi::console_putchar;</span><br><span class="line"><span class="keyword">use</span> core::fmt::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">console_putchar</span>(c <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试功能：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成内核镜像</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动Qemu模拟器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">    -machine virt \</span></span><br><span class="line"><span class="language-bash">    -nographic \</span></span><br><span class="line"><span class="language-bash">    -bios ../bootloader/rustsbi-qemu.bin \</span></span><br><span class="line"><span class="language-bash">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行结果如图：</span></span><br><span class="line">[rustsbi] RustSBI version 0.4.0-alpha.1, adapting to RISC-V SBI v2.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.3</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87e00000..0x87e01290</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">Hello, world!</span><br><span class="line">Panicked at src/main.rs:23 Shutdown machine!</span><br></pre></td></tr></table></figure><h2 id="程序内存布局与编译流程"><a href="#程序内存布局与编译流程" class="headerlink" title="程序内存布局与编译流程"></a>程序内存布局与编译流程</h2><h3 id="程序内存布局"><a href="#程序内存布局" class="headerlink" title="程序内存布局"></a>程序内存布局</h3><p>在我们将源代码编译为可执行文件之后，它就会变成一个看似充满了杂乱无章的字节的一个文件。但我们知道这些字节至少可以分成代码和数据两部分，在程序运行起来的时候它们的功能并不相同：代码部分由一条条可以被 CPU 解码并执行的指令组成，而数据部分只是被 CPU 视作可读写的内存空间。事实上我们还可以根据其功能进一步把两个部分划分为更小的单位： <strong>段</strong> (Section) 。不同的段会被编译器放置在内存不同的位置上，这构成了程序的 <strong>内存布局</strong> (Memory Layout)。一种典型的程序相对内存布局如下所示：</p><p><img src="/public/image/tuos/MemoryLayout.png" alt="MemoryLayout"></p><p>在上图中可以看到，代码部分只有代码段 <code>.text</code> 一个段，存放程序的所有汇编代码。而数据部分则还可以继续细化：</p><ul><li>已初始化数据段保存程序中那些已初始化的全局数据，分为 <code>.rodata</code> 和 <code>.data</code> 两部分。前者存放只读的全局数据，通常是一些常数或者是 常量字符串等；而后者存放可修改的全局数据。</li><li>未初始化数据段 <code>.bss</code> 保存程序中那些未初始化的全局数据，通常由程序的加载者代为进行零初始化，即将这块区域逐字节清零；</li><li><strong>堆</strong> （heap）区域用来存放程序运行时动态分配的数据，如 C&#x2F;C++ 中的 malloc&#x2F;new 分配到的数据本体就放在堆区域，它向高地址增长；</li><li><strong>栈</strong> （stack）区域不仅用作函数调用上下文的保存与恢复，每个函数作用域内的局部变量也被编译器放在它的栈帧内，它向低地址增长。</li></ul><blockquote><p><strong>局部变量与全局变量</strong></p><p>在一个函数的视角中，它能够访问的变量包括以下几种：</p><ul><li>函数的输入参数和局部变量：保存在一些寄存器或是该函数的栈帧里面，如果是在栈帧里面的话是基于当前栈指针加上一个偏移量来访问的；</li><li>全局变量：保存在数据段 <code>.data</code> 和 <code>.bss</code> 中，某些情况下 gp(x3) 寄存器保存两个数据段中间的一个位置，于是全局变量是基于 gp 加上一个偏移量来访问的。</li><li>堆上的动态变量：本体被保存在堆上，大小在运行时才能确定。而我们只能 <em>直接</em> 访问栈上或者全局数据段中的 <strong>编译期确定大小</strong> 的变量。因此我们需要通过一个运行时分配内存得到的一个指向堆上数据的指针来访问它，指针的位宽确实在编译期就能够确定。该指针即可以作为局部变量放在栈帧里面，也可以作为全局变量放在全局数据段中。</li></ul></blockquote><h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>从源代码得到可执行文件的编译流程可被细化为多个阶段（虽然输入一条命令便可将它们全部完成）：</p><ul><li><p><strong>编译器</strong> (Compiler) 将每个源文件从某门高级编程语言转化为汇编语言，注意此时源文件仍然是一个 ASCII 或其他编码的文本文件；</p></li><li><p><strong>汇编器</strong> (Assembler) 将上一步的每个源文件中的文本格式的指令转化为机器码，得到一个二进制的 <strong>目标文件</strong> (Object File)；</p></li><li><p><strong>链接器</strong> (Linker) 将上一步得到的所有目标文件以及一些可能的外部目标文件链接在一起形成一个完整的可执行文件。</p></li></ul><p>汇编器输出的每个目标文件都有一个独立的程序内存布局，它描述了目标文件内各段所在的位置。而链接器所做的事情是将所有输入的目标文件整合成一个整体的内存布局。在此期间链接器主要完成两件事情：</p><ul><li>第一件事情是将来自不同目标文件的段在目标内存布局中重新排布。如下图所示，在链接过程中，分别来自于目标文件 <code>1.o</code> 和 <code>2.o</code> 段被按照段的功能进行分类，相同功能的段被排在一起放在拼装后的目标文件 <code>output.o</code> 中。注意到，目标文件 <code>1.o</code> 和 <code>2.o</code> 的内存布局是存在冲突的，同一个地址在不同的内存布局中存放不同的内容。而在合并后的内存布局中，这些冲突被消除。</li></ul><p>​<img src="/public/image/tuos/MemoryLayout-Linker.png" alt="MemoryLayout-Linker"></p><ul><li><p>第二件事情是将符号替换为具体地址。这里的符号指什么呢？我们知道，在我们进行模块化编程的时候，每个模块都会提供一些向其他模块公开的全局变量、函数等供其他模块访问，也会访问其他模块向它公开的内容。要访问一个变量或者调用一个函数，在源代码级别我们只需知道它们的名字即可，这些名字被我们称为符号。取决于符号来自于模块内部还是其他模块，我们还可以进一步将符号分成内部符号和外部符号。然而，在机器码级别（也即在目标文件或可执行文件中）我们并不是通过符号来找到索引我们想要访问的变量或函数，而是直接通过变量或函数的地址。例如，如果想调用一个函数，那么在指令的机器码中我们可以找到函数入口的绝对地址或者相对于当前 PC 的相对地址。</p><p>那么，符号何时被替换为具体地址呢？因为符号对应的变量或函数都是放在某个段里面的固定位置（如全局变量往往放在 <code>.bss</code> 或者 <code>.data</code> 段中，而函数则放在 <code>.text</code> 段中），所以我们需要等待符号所在的段确定了它们在内存布局中的位置之后才能知道它们确切的地址。当一个模块被转化为目标文件之后，它的内部符号就已经在目标文件中被转化为具体的地址了，因为目标文件给出了模块的内存布局，也就意味着模块内的各个段的位置已经被确定了。然而，此时模块所用到的外部符号的地址无法确定。我们需要将这些外部符号记录下来，放在目标文件一个名为符号表（Symbol table）的区域内。由于后续可能还需要重定位，内部符号也同样需要被记录在符号表中。</p><p>外部符号需要等到链接的时候才能被转化为具体地址。假设模块 1 用到了模块 2 提供的内容，当两个模块的目标文件链接到一起的时候，它们的内存布局会被合并，也就意味着两个模块的各个段的位置均被确定下来。此时，模块 1 用到的来自模块 2 的外部符号可以被转化为具体地址。同时我们还需要注意：两个模块的段在合并后的内存布局中被重新排布，其最终的位置有可能和它们在模块自身的局部内存布局中的位置相比已经发生了变化。因此，每个模块的内部符号的地址也有可能会发生变化，我们也需要进行修正。上面的过程被称为重定位（Relocation），这个过程形象一些来说很像拼图：由于模块 1 用到了模块 2 的内容，因此二者分别相当于一块凹进和凸出一部分的拼图，正因如此我们可以将它们无缝地拼接到一起。</p></li></ul><p>上面我们简单介绍了程序内存布局和编译流程特别是链接过程的相关知识。那么如何得到一个能够在 Qemu 上成功运行的内核镜像呢？首先我们需要通过链接脚本调整内核可执行文件的内存布局，使得内核被执行的第一条指令位于地址 <code>0x80200000</code> 处，同时代码段所在的地址应低于其他段。这是因为 Qemu 物理内存中低于 <code>0x80200000</code> 的区域并未分配给内核，而是主要由 RustSBI 使用。其次，我们需要将内核可执行文件中的元数据丢掉得到内核镜像，此内核镜像仅包含实际会用到的代码和数据。这则是因为 Qemu 的加载功能过于简单直接，它直接将输入的文件逐字节拷贝到物理内存中，因此也可以说这一步是我们在帮助 Qemu 手动将可执行文件加载到物理内存中。下一节我们将成功生成内核镜像并在 Qemu 上验证控制权被转移到内核。</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的安装与配置</title>
      <link href="/Git/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/Git/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &#x27;kay.wang&#x27;</span><br><span class="line"></span><br><span class="line">git config --global user.email &#x27;cn.kay.wang@gmail.com&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="生成本地密钥"><a href="#生成本地密钥" class="headerlink" title="生成本地密钥"></a>生成本地密钥</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;cn.kay.wang@gmail.com&#x27;</span><br></pre></td></tr></table></figure><p>下面一路回车即可</p><h1 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h1><h3 id="bash-ssh-keygen-command-not-found"><a href="#bash-ssh-keygen-command-not-found" class="headerlink" title="-bash: ssh-keygen: command not found"></a>-bash: ssh-keygen: command not found</h3><p>未安装SSH</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S openssh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git简单用法</title>
      <link href="/Git/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/Git/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h1><h3 id="删除远程库中指定文件"><a href="#删除远程库中指定文件" class="headerlink" title="删除远程库中指定文件"></a>删除远程库中指定文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached a/2.txt //删除a目录下的2.txt文件   删除a目录git rm -r --cached a</span><br><span class="line">git commit -m &quot;删除a目录下的2.txt文件&quot; </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2环境配置</title>
      <link href="/OS/tuos/WSL2%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/OS/tuos/WSL2%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="arch-Linux"><a href="#arch-Linux" class="headerlink" title="arch Linux"></a>arch Linux</h2><h3 id="WSL2"><a href="#WSL2" class="headerlink" title="WSL2"></a>WSL2</h3><h4 id="1-勾选适用于Linux的Windows子系统后重启"><a href="#1-勾选适用于Linux的Windows子系统后重启" class="headerlink" title="1.勾选适用于Linux的Windows子系统后重启"></a>1.勾选适用于Linux的Windows子系统<strong>后</strong>重启</h4><h4 id="2-启用虚拟机功能"><a href="#2-启用虚拟机功能" class="headerlink" title="2.启用虚拟机功能"></a>2.启用虚拟机功能</h4><p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要<a href="https://learn.microsoft.com/zh-cn/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed">虚拟化功能</a>才能使用此功能。</p><p>以管理员身份打开 PowerShell 并运行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><p><strong>重新启动</strong>计算机，以完成 WSL 安装并更新到 WSL 2。</p><h4 id="3-下载Linux内核更新包"><a href="#3-下载Linux内核更新包" class="headerlink" title="3.下载Linux内核更新包"></a>3.下载Linux内核更新包</h4><p>从<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">官网</a>下载最新的Linux内核更新包并<strong>安装</strong>；</p><p><strong>管理员</strong>身份打开PowerShell：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; wsl.exe <span class="literal">--update</span></span><br><span class="line">正在检查更新。</span><br><span class="line">已安装最新版本的适用于 Linux 的 Windows 子系统。</span><br></pre></td></tr></table></figure><h4 id="4-将WSL2设置为默认版本"><a href="#4-将WSL2设置为默认版本" class="headerlink" title="4.将WSL2设置为默认版本"></a>4.将WSL2设置为默认版本</h4><p>打开 PowerShell，然后在安装新的 Linux 发行版前运行以下命令，将 WSL 2 设置为默认版本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; wsl <span class="literal">--set-default-version</span> <span class="number">2</span></span><br><span class="line">有关与 WSL <span class="number">2</span> 关键区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line">操作成功完成。</span><br></pre></td></tr></table></figure><h4 id="5-安装所选的Linux分发"><a href="#5-安装所选的Linux分发" class="headerlink" title="5.安装所选的Linux分发"></a>5.安装所选的Linux分发</h4><p>打开 <a href="https://aka.ms/wslstore">Microsoft Store</a>，并选择你偏好的 Linux 分发版。（我这里使用的是arch Linux）</p><p>首次启动新安装的 Linux 分发版时，将打开一个控制台窗口，系统会要求你等待一分钟或两分钟，以便文件解压缩并存储到电脑上。</p><p>然后，需要<a href="https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment#set-up-your-linux-username-and-password">为新的 Linux 分发版创建用户帐户和密码</a>。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Installing,this may take a few minutes...</span><br><span class="line">Iainstallation successful!</span><br><span class="line">Please create a default UNIX user account, The username does not needor to match your windows username.</span><br><span class="line"><span class="keyword">For</span> more information visit: https://aka.ms/wslusers</span><br><span class="line">Enter new UNIX username:</span><br></pre></td></tr></table></figure><h4 id="6-查看当前环境的wsl版本和对应子系统"><a href="#6-查看当前环境的wsl版本和对应子系统" class="headerlink" title="6.查看当前环境的wsl版本和对应子系统"></a>6.查看当前环境的wsl版本和对应子系统</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在Windows终端中键入</span><br><span class="line">&gt; wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br><span class="line">  NAME    STATE           VERSION</span><br><span class="line">* Arch    Running         <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="7-注销安装的Linux子系统账户"><a href="#7-注销安装的Linux子系统账户" class="headerlink" title="7.注销安装的Linux子系统账户"></a>7.注销安装的Linux子系统账户</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; wsl <span class="literal">--unregister</span> Arch</span><br></pre></td></tr></table></figure><p>（名称要与wsl -l -v 命令中NAME一致）</p><h4 id="8-删除安装的Linux子系统"><a href="#8-删除安装的Linux子系统" class="headerlink" title="8.删除安装的Linux子系统"></a>8.删除安装的Linux子系统</h4><p>此电脑-&gt;应用 -&gt; 安装的应用 删除Arch WSL。</p><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syyu // 防止软件库更新导致某些功能无法使用</span><br><span class="line">sudo pacman -S neovim</span><br><span class="line">sudo nvim /etc/pacman.conf 尾部添加</span><br><span class="line"></span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Never</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/$repo/$arch</span><br><span class="line"></span><br><span class="line">顺便开启</span><br><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br><span class="line"></span><br><span class="line">sudo pacman -Syyu</span><br><span class="line">sudo pacman -S yay</span><br></pre></td></tr></table></figure><h2 id="c-Rust-环境配置"><a href="#c-Rust-环境配置" class="headerlink" title="c&#x2F;Rust 环境配置"></a>c&#x2F;Rust 环境配置</h2><h4 id="1-更新-同步arch-Linux内核"><a href="#1-更新-同步arch-Linux内核" class="headerlink" title="1.更新&#x2F;同步arch Linux内核"></a>1.更新&#x2F;同步arch Linux内核</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure><p><strong>这里cmd中需要管理员模式启动</strong>（WSL2中不要开梯子）</p><h4 id="2-C开发环境配置"><a href="#2-C开发环境配置" class="headerlink" title="2.C开发环境配置"></a>2.C开发环境配置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S git base-devel riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-emulators-full riscv64-elf-gdb</span><br></pre></td></tr></table></figure><h4 id="3-Rust开发环境配置"><a href="#3-Rust开发环境配置" class="headerlink" title="3.Rust开发环境配置"></a>3.Rust开发环境配置</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.<span class="number">2</span> -sSf https:<span class="comment">//sh.rustup.rs | sh</span></span><br></pre></td></tr></table></figure><p>测试是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo --version // 如果cargo无效则重新打开终端进入Linux即可</span></span><br><span class="line">cargo 1.77.1 (e52e36006 2024-03-26)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version</span></span><br><span class="line">rustc 1.77.1 (7cf61ebde 2024-03-27)</span><br></pre></td></tr></table></figure><p>切换 nightly 版本，并设置为 rustc 的缺省版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup install nightly</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup default nightly</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version</span></span><br><span class="line">rustc 1.79.0-nightly (385fa9d84 2024-04-04)</span><br></pre></td></tr></table></figure><p>安装一些Rust相关的软件包:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target add riscv64gc-unknown-none-elf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo install cargo-binutils</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add llvm-tools-preview</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add rust-src</span></span><br></pre></td></tr></table></figure><h2 id="Qemu模拟器"><a href="#Qemu模拟器" class="headerlink" title="Qemu模拟器"></a>Qemu模拟器</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S qemu</span><br></pre></td></tr></table></figure><p>三个选择：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1)qemu-base   2)qemu-desktop   3)qemu-full</span><br></pre></td></tr></table></figure><p>第一个提示中提示中选择<code>3</code>，第二个提示默认<code>1</code>即可。</p><h4 id="确认-QEMU-的版本："><a href="#确认-QEMU-的版本：" class="headerlink" title="确认 QEMU 的版本："></a>确认 QEMU 的版本：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 --version</span></span><br><span class="line">QEMU emulator version 9.0.0</span><br><span class="line">Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 --version</span></span><br><span class="line">qemu-riscv64 version 9.0.0</span><br><span class="line">Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>获取代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/rcore-os/rCore-Tutorial-v3.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> rCore-Tutorial-v3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout ch1</span></span><br></pre></td></tr></table></figure><p>在Qemu模拟的计算机上运行: （第一次可能会有些很慢）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> os</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LOG=TRACE make run</span></span><br><span class="line"></span><br><span class="line">(rustup target list | grep &quot;riscv64gc-unknown-none-elf (installed)&quot;) || rustup target add riscv64gc-unknown-none-elf</span><br><span class="line">riscv64gc-unknown-none-elf (installed)</span><br><span class="line">cargo install cargo-binutils</span><br><span class="line">    Updating crates.io index</span><br><span class="line">     Ignored package `cargo-binutils v0.3.6` is already installed, use --force to override</span><br><span class="line">rustup component add rust-src</span><br><span class="line">info: component &#x27;rust-src&#x27; is up to date</span><br><span class="line">rustup component add llvm-tools-preview</span><br><span class="line">info: component &#x27;llvm-tools&#x27; for target &#x27;x86_64-unknown-linux-gnu&#x27; is up to date</span><br><span class="line">Platform: qemu</span><br><span class="line">    Finished release [optimized + debuginfo] target(s) in 0.00s</span><br><span class="line">[rustsbi] RustSBI version 0.3.1, adapting to RISC-V SBI v1.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87e00000..0x87e010f6</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">[kernel] Hello, world!</span><br><span class="line">[TRACE] [kernel] .text [0x80200000, 0x80202000)</span><br><span class="line">[DEBUG] [kernel] .rodata [0x80202000, 0x80203000)</span><br><span class="line">[ INFO] [kernel] .data [0x80203000, 0x80204000)</span><br><span class="line">[ WARN] [kernel] boot_stack top=bottom=0x80214000, lower_bound=0x80204000</span><br><span class="line">[ERROR] [kernel] .bss [0x80214000, 0x80215000)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust版本概述</title>
      <link href="/Rust/basic/%E7%89%88%E6%9C%AC/"/>
      <url>/Rust/basic/%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Rust版本概述"><a href="#Rust版本概述" class="headerlink" title="Rust版本概述"></a>Rust版本概述</h1><h2 id="语义化版本"><a href="#语义化版本" class="headerlink" title="语义化版本"></a>语义化版本</h2><ul><li><p>格式：主版本号.次版本号.修订号，以此用 . 隔开</p><p>主版本号：当做了不兼容的 API 修改。</p><p>次版本号：当做了向下兼容的功能性递增。</p><p>修订号：   当做了向下兼容的问题修正。</p></li></ul><h2 id="发行版本"><a href="#发行版本" class="headerlink" title="发行版本"></a>发行版本</h2><p>Nightly：开发版；</p><p>Beta：测试版；</p><p>Stable：稳定版；</p><h2 id="Edition版次"><a href="#Edition版次" class="headerlink" title="Edition版次"></a>Edition版次</h2><ol><li>2015 Edition</li><li>2018 Edition</li><li>2021 Edition</li></ol><h2 id="Rust-编译过程"><a href="#Rust-编译过程" class="headerlink" title="Rust 编译过程"></a>Rust 编译过程</h2><p><img src="/blogimg/rust/rust-bygc.png" alt="rust-bygc"></p><p>Rust 源码文本作为UTF-8 编码序列输入到编译器，通过分词把词法结构处理为词条流，词条流经过语法解析行程抽象语法树，抽象语法树降级（简化）为高级中间语言（HIR），高级中间语言被用于编译器对代码进行类型检查方法查找等工作，高级中间语言继续降级（简化）为中级中间语言（MIR），中级中间语言被用于借用检查、优化、代码生成（宏、泛型、单态化）等工作，中级中间语言（MIR）优化为LLVM中间语言，最后交给LLVM编译器生成机器码。</p><p>对于编译器来说，所有的版次（Edition）在到达（MIR）时已经消除了版次的差异。（MIR） 是多个Edition的通用语言。</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> Rust-基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crate与模块</title>
      <link href="/Rust/basic/crate%E4%B8%8E%E6%A8%A1%E5%9D%97/"/>
      <url>/Rust/basic/crate%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="crate与模块"><a href="#crate与模块" class="headerlink" title="crate与模块"></a>crate与模块</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> Rust-基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先搜索</title>
      <link href="/Algorithm/DFS/"/>
      <url>/Algorithm/DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="depth-first-search-DFS-深度优先搜索"><a href="#depth-first-search-DFS-深度优先搜索" class="headerlink" title="depth first search ( DFS) 深度优先搜索"></a>depth first search ( DFS) 深度优先搜索</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
