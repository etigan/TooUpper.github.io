<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深度优先搜索</title>
    <url>/Algorithm/DFS/</url>
    <content><![CDATA[<h1 id="depth-first-search-DFS-深度优先搜索"><a href="#depth-first-search-DFS-深度优先搜索" class="headerlink" title="depth first search ( DFS) 深度优先搜索"></a>depth first search ( DFS) 深度优先搜索</h1>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>git简单用法</title>
    <url>/Git/%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h1><h3 id="删除远程库中指定文件"><a href="#删除远程库中指定文件" class="headerlink" title="删除远程库中指定文件"></a>删除远程库中指定文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm -r --cached a/2.txt //删除a目录下的2.txt文件   删除a目录git rm -r --cached a</span><br><span class="line">git commit -m &quot;删除a目录下的2.txt文件&quot; </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的安装与配置</title>
    <url>/Git/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#x27;kay.wang&#x27;</span><br><span class="line"></span><br><span class="line">git config --global user.email &#x27;cn.kay.wang@gmail.com&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="生成本地密钥"><a href="#生成本地密钥" class="headerlink" title="生成本地密钥"></a>生成本地密钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;cn.kay.wang@gmail.com&#x27;</span><br></pre></td></tr></table></figure>

<p>下面一路回车即可</p>
<h1 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h1><h3 id="bash-ssh-keygen-command-not-found"><a href="#bash-ssh-keygen-command-not-found" class="headerlink" title="-bash: ssh-keygen: command not found"></a>-bash: ssh-keygen: command not found</h3><p>未安装SSH</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S openssh</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式工具介绍</title>
    <url>/OS/OS%20Course/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>参与编译和运行的机器根据其角色可以分成以下三类</p>
<ul>
<li>构建(build)系统：<code>生成编译器可执行程序</code>的计算机系统。(生成编译器的电脑)</li>
<li>主机(host)系统：<code>运行编译器可执行程序，编译链接应用程序</code>的计算机系统。(生成应用程序的电脑)</li>
<li>目标(target)系统：<code>运行应用程序</code>的计算机系统。(执行应用程序的电脑)</li>
</ul>
<p>根据 build&#x2F;host&#x2F;target 的不同组合我们可以得到如下的编译方式分类</p>
<ul>
<li>本地(native)编译：<strong>build &#x3D;&#x3D; host &#x3D;&#x3D; target</strong></li>
<li>交叉(cross)编译： <strong>build &#x3D;&#x3D; host !&#x3D; target</strong></li>
</ul>
<h2 id="调试器-GDB"><a href="#调试器-GDB" class="headerlink" title="调试器 GDB"></a>调试器 GDB</h2><ul>
<li><a href="https://ww.gnu.org/software/gdb">https://ww.gnu.org/software/gdb</a></li>
<li>GDB(The GNU Project Debugger)，GNU 项目调试器，用于查看另一个程序在执行过程中正在执行的操作，或该程序崩溃时正在执行的操作。</li>
<li>被调试的程序可能与 GDB 在同一台计算机上执行，也可能在另一台计算机(远程)上或者在模拟器上执行。</li>
<li>GDB 支持调试多种语言：如 Rust 等。</li>
</ul>
<p><img src="/public/image/OS/os/GDB.png" alt="GDB"></p>
<blockquote>
<p>当执行<code>gdb a.out</code>后发生了什么</p>
<p>本地调试时</p>
<p>gdb运行起来之后他会在本地先 <em>fork</em> 一个子进程去运行 <code>a.out</code>，然后 <em>gdb</em> 本身也会运行在一个子进程中，二者通过 <em>ptrace</em> 这个系统调用建立连接；当你在 <em>gdb</em> 中运行至<code>a.out</code> 中的断点时，他就会把 <code>a.out</code> 这个所在的进程挂起来进入阻塞状态。</p>
<p>远程调试时</p>
<p>首先会在目标机器上启动一个名叫 <em>gdbServer</em> 的远程服务，本地的 <em>gdb</em> 会与 <em>gdbServer</em> 建立连接，由 <em>gdbServer</em> 来代理我们的调试过程; <code>a.out</code> 和 <em>gdbServer</em> 运行在目标机器上。</p>
<p>调试机器和目标机器通过网络进行连接。</p>
</blockquote>
<h3 id="GDB基本调试流程"><a href="#GDB基本调试流程" class="headerlink" title="GDB基本调试流程"></a>GDB基本调试流程</h3><h2 id="模拟器-QEMU"><a href="#模拟器-QEMU" class="headerlink" title="模拟器 QEMU"></a>模拟器 QEMU</h2><ul>
<li><a href="https://www.qemu.org/">https://www.qemu.org/</a></li>
<li>QEMU是一套由(Fabrice Bellard)编写的以 GPL 许可证分发源代码的计算机系统模拟软件，在 GNU&#x2F;Linux 平台上被广泛使用。</li>
<li>支持多种体系架构。譬如：RISC-V、X86等。</li>
<li>QEMU 有两种主要运行模式<ul>
<li>User mode：直接运行应用程序。</li>
<li>System mode：模拟整个计算机系统，包括中央处理器及其他周边设变。</li>
</ul>
</li>
</ul>
<h2 id="项目构造工具-Make"><a href="#项目构造工具-Make" class="headerlink" title="项目构造工具 Make"></a>项目构造工具 Make</h2><ul>
<li><a href="https://ww.gnu.org/software/make/">https://ww.gnu.org/software/make/</a></li>
<li>Make 是什么<ul>
<li>make 是一种自动化工程管理工具。</li>
</ul>
</li>
<li>Makefile 是什么<ul>
<li>配合 make，用于描述构建过程中所管理的对象以及如何构造工程的过程。</li>
</ul>
</li>
<li>Make 如何找到 Makefile<ul>
<li>隐士查找：当前目录下按顺序查找名为”GNUmakefule”、”makefile”、”Makefile”的文件。</li>
<li>显示查找：-f</li>
</ul>
</li>
</ul>
<h3 id="Makefile-的构成"><a href="#Makefile-的构成" class="headerlink" title="Makefile 的构成"></a>Makefile 的构成</h3><ul>
<li><p>Makefile 由一条或者多条规则(fule)构成。</p>
</li>
<li><p>每条规则由三要素构成</p>
<ul>
<li>target：目标，可以是 obj 文件也可以是可执行文件。</li>
<li>prerequisites：生成 target 所需要的依赖。</li>
<li>command：为了生成 target 需要执行的命令，可以有多条。</li>
</ul>
</li>
<li><p>一个简单的 Makefile 如下</p>
</li>
<li><pre><code class="makefile"># 定义 Makefile 中的一些变量名
# = 为简单赋值 := 为赋值展开，即如果后续更改了用于赋值的变量的值，那么这个改变不会影响已经赋值的变量。
TARGET := riscv64gc-unknown-none-elf
MODE := release
APP_DIR := src/bin
TARGET_DIR := target/$(TARGET)/$(MODE)
APPS := $(wildcard $(APP_DIR)/*.rs)
ELFS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%, $(APPS))
BINS := $(patsubst $(APP_DIR)/%.rs, $(TARGET_DIR)/%.bin, $(APPS))

OBJDUMP := rust-objdump --arch-name=riscv64
OBJCOPY := rust-objcopy --binary-architecture=riscv64

elf:
    @cargo build --release --target $(TARGET)

binary: elf
    @$(foreach elf, $(ELFS), $(OBJCOPY) $(elf) --strip-all -O binary $(patsubst $(TARGET_DIR)/%, $(TARGET_DIR)/%.bin, $(elf));)

build: binary
</code></pre>
</li>
<li><p>行注释以 # 开头</p>
</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟内存</title>
    <url>/OS/OS%20Course/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>目标：</p>
<ul>
<li>是在较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用。</li>
</ul>
<h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><h2 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h2>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>应用程序与基本执行环境</title>
    <url>/OS/tuos/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="应用程序与基本执行环境"><a href="#应用程序与基本执行环境" class="headerlink" title="应用程序与基本执行环境"></a>应用程序与基本执行环境</h1><h2 id="创建一个bin项目"><a href="#创建一个bin项目" class="headerlink" title="创建一个bin项目"></a>创建一个bin项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> tuos</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> tuos</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new os --bin</span></span><br><span class="line">    Creating binary (application) `os` package</span><br><span class="line">note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br></pre></td></tr></table></figure>

<h2 id="移除执行环境对操作系统的依赖"><a href="#移除执行环境对操作系统的依赖" class="headerlink" title="移除执行环境对操作系统的依赖"></a>移除执行环境对操作系统的依赖</h2><h3 id="1-添加目标平台"><a href="#1-添加目标平台" class="headerlink" title="1.添加目标平台"></a>1.添加目标平台</h3><ol>
<li>我们要构建一个可以在裸机上运行的 RISC-V架构的操作系统，那么就需要添加对目标平台的支持：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tuos/os</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target add riscv64gc-unknown-none-elf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version --verbose</span></span><br><span class="line">rustc 1.79.0-nightly (385fa9d84 2024-04-04)</span><br><span class="line">binary: rustc</span><br><span class="line">commit-hash: 385fa9d845dd326c6bbfd58c22244215e431948a</span><br><span class="line">commit-date: 2024-04-04</span><br><span class="line">host: x86_64-unknown-linux-gnu</span><br><span class="line">release: 1.79.0-nightly</span><br><span class="line">LLVM version: 18.1.2</span><br></pre></td></tr></table></figure>

<p>这条命令有几个作用：</p>
<ol>
<li><p><strong>识别目标平台：</strong></p>
<ul>
<li><code>riscv64gc</code> 表示 RISC-V 64位通用计算（General-Purpose Computing）架构（ CPU 架构）。</li>
<li><code>unknown</code> 表示 Rust 不了解这个目标的操作系统或供应商信息（CPU 厂商）。</li>
<li><code>none</code> 表示没有操作系统，这通常用于裸机编程（操作系统）。</li>
<li><code>elf</code> 表示没有标准的运行时库（没有任何系统调用的封装支持），但可以生成 ELF 格式的执行程序（运行时库）。</li>
</ul>
</li>
<li><p><strong>安装必要组件：</strong>如果 <code>rustup</code> 有为 <code>riscv64gc-unknown-none-elf</code> 准备的预编译组件，它会尝试下载并安装这些组件。</p>
</li>
<li><p><strong>更新Rust工具链配置：</strong>在 Rust 配置中添加对新目标的支持，这样当你使用 <code>cargo build --target riscv64gc-unknown-none-elf</code> 命令时，Cargo 就会知道如何为 <code>riscv64gc-unknown-none-elf</code> 目标构建你的项目。</p>
</li>
</ol>
<p>可以使用如下命令查看当前Rust工具链支持的所有目标平台:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target list</span></span><br></pre></td></tr></table></figure>

<p>2.在 <code>tuos</code> 目录下新建 <code>.cargo</code> 目录，并在这个目录下创建 <code>config</code> 文件，并在里面输入如下内容：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">#  tuos/os/.cargo/config</span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = <span class="string">&quot;riscv64gc-unknown-none-elf&quot;</span></span><br></pre></td></tr></table></figure>

<p>这会对于 Cargo 工具在 os 目录下的行为进行调整：<strong>现在默认会使用 riscv64gc 作为目标平台而不是原先的默认 x86_64-unknown-linux-gnu。</strong></p>
<h3 id="2-移除标准库依赖"><a href="#2-移除标准库依赖" class="headerlink" title="2.移除标准库依赖"></a>2.移除标准库依赖</h3><p>我们希望它能够被编译到 RV64GC 裸机平台上，为此我们需要移除它对于 Rust std标准库的依赖，因为 Rust std标准库自己就需要操作系统内核的支持。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/os/src/main.rs</span><br><span class="line"><span class="comment">// 告诉 Rust 编译器不使用 Rust 标准库 std 转而使用核心库 core（core库不需要操作系统的支持）;</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 注释掉println!宏,它是由标准库 std 提供的且会使用到一个名为 write 的系统调用;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-添加错误处理机制"><a href="#3-添加错误处理机制" class="headerlink" title="3.添加错误处理机制"></a>3.添加错误处理机制</h3><p>Rust编译器在编译程序时，从安全性考虑，需要有 <code>panic!</code> 宏的具体实现。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/lang_items.rs</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"><span class="comment">// 指定一个函数作为程序的 panic 处理程序。</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在把 <code>panic_handler</code> 配置在单独的文件 <code>tuos/src/lang_items.rs</code> 后，需要在os&#x2F;src&#x2F;main.rs文件中添加以下内容才能正常编译整个软件：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标准库(std)依赖</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入外部模块，内容为对panic!的具体实现</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br></pre></td></tr></table></figure>

<h3 id="4-移除标准main函数"><a href="#4-移除标准main函数" class="headerlink" title="4.移除标准main函数"></a>4.移除标准main函数</h3><p>应用程序在执行之前进行一些初始化工作，然后才跳转到应用程序的入口点（也就是跳转到我们编写的 <code>main</code> 函数）开始执行。 <code>start</code> 语义项代表了标准库 std 在执行应用程序之前需要进行的一些初始化工作。由于我们禁用了标准库，编译器也就找不到这项功能的实现了。最简单的解决方案就是压根不让编译器使用这项功能。我们在 <code>main.rs</code> 的开头加入设置 <code>#![no_main]</code> 告诉编译器我们没有一般意义上的 <code>main</code> 函数，并将原来的 <code>main</code> 函数删除。在失去了 <code>main</code> 函数的情况下，编译器也就不需要完成所谓的初始化工作了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除标准库(std)依赖</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 禁用标准main函数</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="comment">// 导入外部模块，内容为对panic!的具体实现</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="comment">// 删掉 自带的main函数</span></span><br></pre></td></tr></table></figure>

<p>至此，我们成功移除了标准库的依赖，并完成了构建裸机平台上操作系统的第一步工作–通过编译器检查并生成执行码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line">warning: `/home/kay/workspace/tuos/os/.cargo/config` is deprecated in favor of `config.toml`</span><br><span class="line">note: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`</span><br><span class="line">   Compiling os v0.1.0 (/home/kay/workspace/tuos/os)</span><br><span class="line">    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.06s</span><br></pre></td></tr></table></figure>

<h2 id="验证Qemu模拟器与执行环境是否正确可用"><a href="#验证Qemu模拟器与执行环境是否正确可用" class="headerlink" title="验证Qemu模拟器与执行环境是否正确可用"></a>验证Qemu模拟器与执行环境是否正确可用</h2><p>下面我们将实践在 Qemu 上执行内核的第一条指令,用以检验环境是否正确可用。</p>
<h3 id="编写内核第一条指令"><a href="#编写内核第一条指令" class="headerlink" title="编写内核第一条指令"></a>编写内核第一条指令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/entry.asm</span></span><br><span class="line">    .section .text.entry # .section: 定义或切换到一个特定的代码段 .text.enery代码段</span><br><span class="line">    .globl _start        # 告知编译器 _start 是一个全局符号,可以被其他目标文件使用</span><br><span class="line">_start:                  # 全局符号,指向下面的(li x1, 100)</span><br><span class="line">    li x1, 100           # 立即数 100 被加载到了寄存器 x1 中</span><br></pre></td></tr></table></figure>

<p>一般情况下，所有的代码都被放到一个名为 <code>.text</code> 的代码段中，这里我们将其命名为 <code>.text.entry</code> 从而区别于其他 <code>.text</code> 的目的在于我们想要确保该段被放置在相比任何其他代码段更低的地址上。这样，作为内核的入口点，这段指令才能被最先执行。</p>
<blockquote>
<p> 常见的 x86、RISC-V 等架构采用的是小端序。</p>
</blockquote>
<p><strong>将汇编代码嵌入<code>main.rs</code>：</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"><span class="comment">// 移除标准库</span></span><br><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="comment">// 移除main函数</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="comment">// 载入模块</span></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="comment">// 引用模块</span></span><br><span class="line"><span class="keyword">use</span> core::arch::global_asm;</span><br><span class="line"><span class="comment">// global_asm!宏：嵌入全局汇编代码;include_str!宏：文件的内容作为一个字符串嵌入到程序中;</span></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关于 <code>main</code> 函数和 <code>global_asm!</code> 的执行顺序，重要的是理解它们的作用和上下文：</strong></p>
<ul>
<li><p><strong>global_asm!</strong>: 这个宏用于在编译时嵌入汇编代码。这些汇编代码通常用于设置中断向量表、初始化硬件或其他低级设置。这些代码在二进制文件的开始或特定段中，并且在程序开始执行时就已经存在。<em>它们并不是在运行时执行的代码，而是作为二进制文件的一部分存在</em>。</p>
</li>
<li><p><strong>main 函数</strong>: 在 Rust 程序中，<code>main</code> 函数是程序的入口点。当程序开始执行时，它首先会跳转到 <code>main</code> 函数。<em>在 <code>main</code> 函数之前，任何全局的初始化代码（包括通过 <code>global_asm!</code> 嵌入的汇编代码）都应该已经完成</em>。</p>
</li>
</ul>
</blockquote>
<h3 id="调整内核的内存布局"><a href="#调整内核的内存布局" class="headerlink" title="调整内核的内存布局"></a>调整内核的内存布局</h3><p>由于链接器默认的内存布局并不能符合我们的要求，为了实现与 Qemu 正确对接，我们可以通过 <strong>链接脚本</strong> (Linker Script) 调整链接器的行为，使得最终生成的可执行文件的内存布局符合Qemu的预期，即内核第一条指令的地址应该位于 0x80200000 。我们修改 Cargo 的配置文件来使用我们自己的链接脚本 <code>os/src/linker.ld</code> 而非使用默认的内存布局：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/.cargo/config</span></span><br><span class="line">[build]</span><br><span class="line">target = &quot;riscv64gc-unknown-none-elf&quot;</span><br><span class="line"></span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    &quot;-Clink-arg=-Tsrc/linker.ld&quot;, &quot;-Cforce-frame-pointers=yes&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>“-Clink-arg&#x3D;-Tsrc&#x2F;linker.ld” ：告诉 Rust 编译器在链接阶段使用 <code>src/linker.ld</code> 作为链接器脚本</li>
<li>“-Cforce-frame-pointers&#x3D;yes” : 强制编译器在生成的代码中包含帧指针。</li>
</ul>
</blockquote>
<p>链接脚本 <code>os/src/linker.ld</code> 如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH(riscv)	# 设置了目标平台为 riscv;</span><br><span class="line">ENTRY(_start)	# 设置了整个程序的入口点为之前定义的全局符号 _start;</span><br><span class="line">BASE_ADDRESS = 0x80200000;	# 定义了一个常量 BASE_ADDRESS 为 0x80200000 ,内核的初始化时的地址;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    skernel = .;</span><br><span class="line"></span><br><span class="line">    stext = .;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    etext = .;</span><br><span class="line">    srodata = .;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    erodata = .;</span><br><span class="line">    sdata = .;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    edata = .;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        *(.bss.stack)</span><br><span class="line">        sbss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(4K);</span><br><span class="line">    ebss = .;</span><br><span class="line">    ekernel = .;</span><br><span class="line"></span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 1 行我们设置了目标平台为 riscv ；第 2 行我们设置了整个程序的入口点为之前定义的全局符号 <code>_start</code>；</p>
<p>第 3 行定义了一个常量 <code>BASE_ADDRESS</code> 为 <code>0x80200000</code> ，也就是我们之前提到内核的初始化代码被放置的地址；</p>
<p>从第 5 行开始体现了链接过程中对输入的目标文件的段的合并。其中 <code>.</code> 表示当前地址，也就是链接器会从它指向的位置开始往下放置从输入的目标文件中收集来的段。我们可以对 <code>.</code> 进行赋值来调整接下来的段放在哪里，也可以创建一些全局符号赋值为 <code>.</code> 从而记录这一时刻的位置。我们还能够看到这样的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata : &#123;</span><br><span class="line">    *(.rodata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒号前面表示最终生成的可执行文件的一个段的名字，花括号内按照放置顺序描述将所有输入目标文件的哪些段放在这个段中，每一行格式为 <code>&lt;ObjectFile&gt;(SectionName)</code>，表示目标文件 <code>ObjectFile</code> 的名为 <code>SectionName</code> 的段需要被放进去。我们也可以使用通配符来书写 <code>&lt;ObjectFile&gt;</code> 和 <code>&lt;SectionName&gt;</code> 分别表示可能的输入目标文件和段名。因此，最终的合并结果是，在最终可执行文件中各个常见的段 <code>.text, .rodata .data, .bss</code> 从低地址到高地址按顺序放置，每个段里面都包括了所有输入目标文件的同名段，且每个段都有两个全局符号给出了它的开始和结束地址（比如 <code>.text</code> 段的开始和结束地址分别是 <code>stext</code> 和 <code>etext</code> ）。</p>
<p>第 12 行我们将包含内核第一条指令的 <code>.text.entry</code> 段放在最终的 <code>.text</code> 段的最开头，同时注意到在最终内存布局中代码段 <code>.text</code> 又是先于任何其他段的。因为所有的段都从 <code>BASE_ADDRESS</code> 也即 <code>0x80200000</code> 开始放置，这就能够保证内核的第一条指令正好放在 <code>0x80200000</code> 从而能够正确对接到 Qemu 上。</p>
<p>生成内核可执行文件，切换到 <code>os</code> 目录下进行以下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以 release 模式生成了内核可执行文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build --release</span></span><br><span class="line">warning: `/home/kay/workspace/tuos/os/.cargo/config` is deprecated in favor of `config.toml`</span><br><span class="line">note: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`</span><br><span class="line">   Compiling os v0.1.0 (/home/kay/workspace/tuos/os)</span><br><span class="line">    Finished `release` profile [optimized] target(s) in 0.06s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 file 工具查看它的属性</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file target/riscv64gc-unknown-none-elf/release/os</span></span><br><span class="line">target/riscv64gc-unknown-none-elf/release/os: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure>

<h3 id="手动加载内核可执行文件"><a href="#手动加载内核可执行文件" class="headerlink" title="手动加载内核可执行文件"></a>手动加载内核可执行文件</h3><p>使用如下命令可以丢弃内核可执行文件中的元数据得到内核镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>cargo build --release</code>后得到的内核可执行文件完全符合我们对于内存布局的要求，但是我们不能将其直接提交给 Qemu ，因为它除了实际会被用到的代码和数据段之外还有一些多余的元数据，这些元数据无法被 Qemu 在加载文件时利用，且会使代码和数据段被加载到错误的位置。所以我们需要将其元数据丢弃</p>
</blockquote>
<h3 id="基于GDB验证启动流程"><a href="#基于GDB验证启动流程" class="headerlink" title="基于GDB验证启动流程"></a>基于GDB验证启动流程</h3><p>在 <code>os</code> 目录下通过以下命令启动 Qemu 并加载 RustSBI 和内核镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">    -machine virt \</span></span><br><span class="line"><span class="language-bash">    -nographic \</span></span><br><span class="line"><span class="language-bash">    -bios ../bootloader/rustsbi-qemu.bin \</span></span><br><span class="line"><span class="language-bash">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \</span></span><br><span class="line"><span class="language-bash">    -s -S</span></span><br></pre></td></tr></table></figure>

<p><code>-s</code> 可以使 Qemu 监听本地 TCP 端口 1234 等待 GDB 客户端连接，而 <code>-S</code> 可以使 Qemu 在收到 GDB 的请求后再开始运行。因此，Qemu 暂时没有任何输出。注意，如果不想通过 GDB 对于 Qemu 进行调试而是直接运行 Qemu 的话，则要删掉最后一行的 <code>-s -S</code> 。</p>
<p>打开另一个终端，启动一个 GDB 客户端连接到 Qemu ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">riscv64-elf-gdb \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;file target/riscv64gc-unknown-none-elf/release/os&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;set arch riscv:rv64&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">    -ex <span class="string">&#x27;target remote localhost:1234&#x27;</span></span></span><br><span class="line">[GDB output]</span><br><span class="line">0x0000000000001000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>可以看到，正如我们在上一节提到的那样，Qemu 启动后 PC 被初始化为 <code>0x1000</code> 。我们可以检查一下 Qemu 的启动固件的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) x/10i <span class="variable">$pc</span></span></span><br><span class="line">=&gt; 0x1000:      auipc   t0,0x0</span><br><span class="line">   0x1004:      add     a2,t0,40</span><br><span class="line">   0x1008:      csrr    a0,mhartid</span><br><span class="line">   0x100c:      ld      a1,32(t0)</span><br><span class="line">   0x1010:      ld      t0,24(t0)</span><br><span class="line">   0x1014:      jr      t0</span><br><span class="line">   0x1018:      unimp</span><br><span class="line">   0x101a:      .2byte  0x8000</span><br><span class="line">   0x101c:      unimp</span><br><span class="line">   0x101e:      unimp</span><br></pre></td></tr></table></figure>

<p>这里 <code>x/10i $pc</code> 的含义是从当前 PC 值的位置开始，在内存中反汇编 10 条指令。不过可以看到 Qemu 的固件仅包含 5 条指令，从 <code>0x1018</code> 开始都是数据，当数据为 0 的时候则会被反汇编为 <code>unimp</code> 指令。 <code>0x101a</code> 处的数据 <code>0x8000</code> 是能够跳转到 <code>0x80000000</code> 进入启动下一阶段的关键。总之，在执行位于 <code>0x1014</code> 的指令之前，寄存器 <code>t0</code> 的值恰好为 <code>0x80000000</code> ，随后通过 <code>jr t0</code> 便可以跳转到该地址。我们可以通过单步调试来复盘这个过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001008 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000000000100c in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001010 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000000001010 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/x <span class="variable">$t0</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0x80000000</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>其中， <code>si</code> 可以让 Qemu 每次向下执行一条指令，之后屏幕会打印出待执行的下一条指令的地址。 <code>p/x $t0</code> 以 16 进制打印寄存器 <code>t0</code> 的值，注意当我们要打印寄存器的时候需要在寄存器的名字前面加上 <code>$</code> 。可以看到，当位于 <code>0x1010</code> 的指令执行完毕后，下一条待执行的指令位于 RustSBI 的入口，也即 <code>0x80000000</code> ，这意味着我们即将把控制权转交给 RustSBI 。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/10i $pc</span><br><span class="line">=&gt; 0x80000000:  auipc   sp,0x29</span><br><span class="line">   0x80000004:  add     sp,sp,-200</span><br><span class="line">   0x80000008:  lui     t0,0x4</span><br><span class="line">   0x8000000a:  add     t1,a0,1</span><br><span class="line">   0x8000000e:  add     sp,sp,t0</span><br><span class="line">   0x80000010:  add     t1,t1,-1</span><br><span class="line">   0x80000012:  bnez    t1,0x8000000e</span><br><span class="line">   0x80000016:  j       0x80015e0c</span><br><span class="line">   0x8000001a:  unimp</span><br><span class="line">   0x8000001c:  add     sp,sp,-32</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080000008 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000008000000a in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x000000008000000e in ?? ()</span><br></pre></td></tr></table></figure>

<p>我们可以用同样的方式反汇编 RustSBI 最初的几条指令并单步调试。不过由于 RustSBI 超出了本书的范围，我们这里并不打算进行深入。接下来我们检查控制权能否被移交给我们的内核：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) b *0x80200000</span></span><br><span class="line">Breakpoint 1 at 0x80200000</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) c</span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000080200000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>我们在内核的入口点，也即地址 <code>0x80200000</code> 处打一个断点。需要注意，当需要在一个特定的地址打断点时，需要在地址前面加上 <code>*</code> 。接下来通过 <code>c</code> 命令（Continue 的缩写）让 Qemu 向下运行直到遇到一个断点。可以看到，我们成功停在了 <code>0x80200000</code> 处。随后，可以检查内核第一条指令是否被正确执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/5i $pc</span><br><span class="line">=&gt; 0x80200000:  li      ra,100</span><br><span class="line">   0x80200004:  unimp</span><br><span class="line">   0x80200006:  unimp</span><br><span class="line">   0x80200008:  unimp</span><br><span class="line">   0x8020000a:  unimp</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) si</span></span><br><span class="line">0x0000000080200004 in ?? ()</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/d <span class="variable">$x1</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 100</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) p/x <span class="variable">$sp</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 0x0</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们在 <code>entry.asm</code> 中编写的第一条指令可以在 <code>0x80200000</code> 处找到。这里 <code>ra</code> 是寄存器 <code>x1</code> 的别名， <code>p/d $x1</code> 可以以十进制打印寄存器 <code>x1</code> 的值，它的结果正确。最后，作为下一节的铺垫，我们可以检查此时栈指针 <code>sp</code> 的值，可以发现它目前是 0 。下一节我们将设置好栈空间，使得内核代码可以正常进行函数调用，随后将控制权转交给 Rust 代码。</p>
<h2 id="设置栈空间以及内核初始化"><a href="#设置栈空间以及内核初始化" class="headerlink" title="设置栈空间以及内核初始化"></a>设置栈空间以及内核初始化</h2><h3 id="分配栈空间"><a href="#分配栈空间" class="headerlink" title="分配栈空间"></a>分配栈空间</h3><p>我们在 <code>entry.asm</code> 中分配启动栈空间，并在控制权被转交给 Rust 入口之前将栈指针 <code>sp</code> 设置为栈顶的位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/entry.asm</span></span><br><span class="line"></span><br><span class="line">    .section .text.entry	# 定义一个段</span><br><span class="line">    .globl _start	# 定义一个全局符号</span><br><span class="line">_start:	# 程序入口</span><br><span class="line">    la sp, boot_stack_top	# 立即将 boot_stack_top 的地址加载到栈指针 sp 中</span><br><span class="line">    call main # 调用一个名为main的子程序</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16	# 为数据段分配一定数量的空间。</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:		# 表示为栈顶 ,上文_start程序入口加载的位置</span><br></pre></td></tr></table></figure>

<blockquote>
<p>综上所述，这段代码定义了程序的入口点 <code>_start</code>，并设置了一个栈空间，栈的顶部是 <code>boot_stack_top</code>，底部是 <code>boot_stack_lower_bound</code>，总共 64KB。程序从 <code>_start</code> 开始执行，首先设置栈指针，然后调用 Rust 编写的 <code>main</code> 函数。</p>
</blockquote>
<h3 id="编写入口函数"><a href="#编写入口函数" class="headerlink" title="编写入口函数"></a>编写入口函数</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不要对该函数名进行修饰，以便其他语言就可以通过该原始名称来链接和调用 Rust 函数或访问 Rust 变量。</span></span><br><span class="line"><span class="comment">// 这里面的main名字要与汇编代码中指定的入口子函数名称一致</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> ! &#123; </span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对-bss-段的清零"><a href="#对-bss-段的清零" class="headerlink" title="对 .bss 段的清零"></a>对 <code>.bss</code> 段的清零</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对.bss段清零</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">clear_bss</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    (sbss <span class="keyword">as</span> <span class="type">usize</span>..ebss <span class="keyword">as</span> <span class="type">usize</span>).for_each(|a| &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在函数 <code>clear_bss</code> 中，我们会尝试从其他地方找到全局符号 <code>sbss</code> 和 <code>ebss</code> ，它们由链接脚本 <code>linker.ld</code> 给出，并分别指出需要被清零的 <code>.bss</code> 段的起始和终止地址。接下来我们只需遍历该地址区间并逐字节进行清零即可。</p>
</blockquote>
<h2 id="使用RustSBI-实现字符打印功能"><a href="#使用RustSBI-实现字符打印功能" class="headerlink" title="使用RustSBI 实现字符打印功能"></a>使用RustSBI 实现字符打印功能</h2><p>RustSBI 通过实现 SBI 标准，使得操作系统能够利用RISC-V处理器的指令集系统来执行各种操作。</p>
<h3 id="调用-SBI-服务"><a href="#调用-SBI-服务" class="headerlink" title="调用 SBI 服务"></a>调用 SBI 服务</h3><p><strong>在 <code>Cargo.toml</code> 中引入 sbi_rt 依赖来调用 SBI 服务的接口：</strong></p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span> <span class="comment"># 因为兼容问题Qemu9.0.0在进行后续学习时候或出错，故将版次改为 2018	</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">sbi-rt</span> = &#123; version = <span class="string">&quot;0.0.2&quot;</span>, features = [<span class="string">&quot;legacy&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>我们将内核与 RustSBI 通信的相关功能实现在子模块 <code>sbi</code> 中，因此我们需要在 <code>main.rs</code> 中加入 <code>mod sbi</code> 将该子模块加入我们的项目。在 <code>os/src/sbi.rs</code> 中，我们直接调用 sbi_rt 提供的接口来将输出字符：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"><span class="keyword">mod</span> sbi;</span><br><span class="line"></span><br><span class="line"># os/src/sbi.rs</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">console_putchar</span>(c: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="comment">// #[allow(deprecated)]属性来禁止编译器发出警告,对于某些已经弃用的方法。</span></span><br><span class="line">    <span class="meta">#[allow(deprecated)]</span></span><br><span class="line">    sbi_rt::legacy::<span class="title function_ invoke__">console_putchar</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现关机功能"><a href="#实现关机功能" class="headerlink" title="实现关机功能"></a>实现关机功能</h3><p><strong>实现关机功能：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">os/src/sbi.rs</span></span><br><span class="line">pub fn shutdown(failure: bool) -&gt; ! &#123;</span><br><span class="line">    use sbi_rt::&#123;system_reset, NoReason, Shutdown, SystemFailure&#125;;</span><br><span class="line">    if !failure &#123;</span><br><span class="line">        system_reset(Shutdown, NoReason);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        system_reset(Shutdown, SystemFailure);</span><br><span class="line">    &#125;</span><br><span class="line">    unreachable!()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">mod</span> console;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/console.rs</span></span><br><span class="line"><span class="keyword">use</span> crate::sbi::console_putchar;</span><br><span class="line"><span class="keyword">use</span> core::fmt::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">console_putchar</span>(c <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试功能：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成内核镜像</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rust-objcopy --strip-all target/riscv64gc-unknown-none-elf/release/os -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动Qemu模拟器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 \</span></span><br><span class="line"><span class="language-bash">    -machine virt \</span></span><br><span class="line"><span class="language-bash">    -nographic \</span></span><br><span class="line"><span class="language-bash">    -bios ../bootloader/rustsbi-qemu.bin \</span></span><br><span class="line"><span class="language-bash">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行结果如图：</span></span><br><span class="line">[rustsbi] RustSBI version 0.4.0-alpha.1, adapting to RISC-V SBI v2.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.3</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87e00000..0x87e01290</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">Hello, world!</span><br><span class="line">Panicked at src/main.rs:23 Shutdown machine!</span><br></pre></td></tr></table></figure>

<h2 id="程序内存布局与编译流程"><a href="#程序内存布局与编译流程" class="headerlink" title="程序内存布局与编译流程"></a>程序内存布局与编译流程</h2><h3 id="程序内存布局"><a href="#程序内存布局" class="headerlink" title="程序内存布局"></a>程序内存布局</h3><p>在我们将源代码编译为可执行文件之后，它就会变成一个看似充满了杂乱无章的字节的一个文件。但我们知道这些字节至少可以分成代码和数据两部分，在程序运行起来的时候它们的功能并不相同：代码部分由一条条可以被 CPU 解码并执行的指令组成，而数据部分只是被 CPU 视作可读写的内存空间。事实上我们还可以根据其功能进一步把两个部分划分为更小的单位： <strong>段</strong> (Section) 。不同的段会被编译器放置在内存不同的位置上，这构成了程序的 <strong>内存布局</strong> (Memory Layout)。一种典型的程序相对内存布局如下所示：</p>
<p><img src="/public/image/OS/tuos/MemoryLayout.png" alt="MemoryLayout"></p>
<p>在上图中可以看到，代码部分只有代码段 <code>.text</code> 一个段，存放程序的所有汇编代码。而数据部分则还可以继续细化：</p>
<ul>
<li>已初始化数据段保存程序中那些已初始化的全局数据，分为 <code>.rodata</code> 和 <code>.data</code> 两部分。前者存放只读的全局数据，通常是一些常数或者是 常量字符串等；而后者存放可修改的全局数据。</li>
<li>未初始化数据段 <code>.bss</code> 保存程序中那些未初始化的全局数据，通常由程序的加载者代为进行零初始化，即将这块区域逐字节清零；</li>
<li><strong>堆</strong> （heap）区域用来存放程序运行时动态分配的数据，如 C&#x2F;C++ 中的 malloc&#x2F;new 分配到的数据本体就放在堆区域，它向高地址增长；</li>
<li><strong>栈</strong> （stack）区域不仅用作函数调用上下文的保存与恢复，每个函数作用域内的局部变量也被编译器放在它的栈帧内，它向低地址增长。</li>
</ul>
<blockquote>
<p><strong>局部变量与全局变量</strong></p>
<p>在一个函数的视角中，它能够访问的变量包括以下几种：</p>
<ul>
<li>函数的输入参数和局部变量：保存在一些寄存器或是该函数的栈帧里面，如果是在栈帧里面的话是基于当前栈指针加上一个偏移量来访问的；</li>
<li>全局变量：保存在数据段 <code>.data</code> 和 <code>.bss</code> 中，某些情况下 gp(x3) 寄存器保存两个数据段中间的一个位置，于是全局变量是基于 gp 加上一个偏移量来访问的。</li>
<li>堆上的动态变量：本体被保存在堆上，大小在运行时才能确定。而我们只能 <em>直接</em> 访问栈上或者全局数据段中的 <strong>编译期确定大小</strong> 的变量。因此我们需要通过一个运行时分配内存得到的一个指向堆上数据的指针来访问它，指针的位宽确实在编译期就能够确定。该指针即可以作为局部变量放在栈帧里面，也可以作为全局变量放在全局数据段中。</li>
</ul>
</blockquote>
<h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>从源代码得到可执行文件的编译流程可被细化为多个阶段（虽然输入一条命令便可将它们全部完成）：</p>
<ul>
<li><p><strong>编译器</strong> (Compiler) 将每个源文件从某门高级编程语言转化为汇编语言，注意此时源文件仍然是一个 ASCII 或其他编码的文本文件；</p>
</li>
<li><p><strong>汇编器</strong> (Assembler) 将上一步的每个源文件中的文本格式的指令转化为机器码，得到一个二进制的 <strong>目标文件</strong> (Object File)；</p>
</li>
<li><p><strong>链接器</strong> (Linker) 将上一步得到的所有目标文件以及一些可能的外部目标文件链接在一起形成一个完整的可执行文件。</p>
</li>
</ul>
<p>汇编器输出的每个目标文件都有一个独立的程序内存布局，它描述了目标文件内各段所在的位置。而链接器所做的事情是将所有输入的目标文件整合成一个整体的内存布局。在此期间链接器主要完成两件事情：</p>
<ul>
<li>第一件事情是将来自不同目标文件的段在目标内存布局中重新排布。如下图所示，在链接过程中，分别来自于目标文件 <code>1.o</code> 和 <code>2.o</code> 段被按照段的功能进行分类，相同功能的段被排在一起放在拼装后的目标文件 <code>output.o</code> 中。注意到，目标文件 <code>1.o</code> 和 <code>2.o</code> 的内存布局是存在冲突的，同一个地址在不同的内存布局中存放不同的内容。而在合并后的内存布局中，这些冲突被消除。</li>
</ul>
<p>​	<img src="/public/image/tuos/MemoryLayout-Linker.png" alt="MemoryLayout-Linker"></p>
<ul>
<li><p>第二件事情是将符号替换为具体地址。这里的符号指什么呢？我们知道，在我们进行模块化编程的时候，每个模块都会提供一些向其他模块公开的全局变量、函数等供其他模块访问，也会访问其他模块向它公开的内容。要访问一个变量或者调用一个函数，在源代码级别我们只需知道它们的名字即可，这些名字被我们称为符号。取决于符号来自于模块内部还是其他模块，我们还可以进一步将符号分成内部符号和外部符号。然而，在机器码级别（也即在目标文件或可执行文件中）我们并不是通过符号来找到索引我们想要访问的变量或函数，而是直接通过变量或函数的地址。例如，如果想调用一个函数，那么在指令的机器码中我们可以找到函数入口的绝对地址或者相对于当前 PC 的相对地址。</p>
<p>那么，符号何时被替换为具体地址呢？因为符号对应的变量或函数都是放在某个段里面的固定位置（如全局变量往往放在 <code>.bss</code> 或者 <code>.data</code> 段中，而函数则放在 <code>.text</code> 段中），所以我们需要等待符号所在的段确定了它们在内存布局中的位置之后才能知道它们确切的地址。当一个模块被转化为目标文件之后，它的内部符号就已经在目标文件中被转化为具体的地址了，因为目标文件给出了模块的内存布局，也就意味着模块内的各个段的位置已经被确定了。然而，此时模块所用到的外部符号的地址无法确定。我们需要将这些外部符号记录下来，放在目标文件一个名为符号表（Symbol table）的区域内。由于后续可能还需要重定位，内部符号也同样需要被记录在符号表中。</p>
<p>外部符号需要等到链接的时候才能被转化为具体地址。假设模块 1 用到了模块 2 提供的内容，当两个模块的目标文件链接到一起的时候，它们的内存布局会被合并，也就意味着两个模块的各个段的位置均被确定下来。此时，模块 1 用到的来自模块 2 的外部符号可以被转化为具体地址。同时我们还需要注意：两个模块的段在合并后的内存布局中被重新排布，其最终的位置有可能和它们在模块自身的局部内存布局中的位置相比已经发生了变化。因此，每个模块的内部符号的地址也有可能会发生变化，我们也需要进行修正。上面的过程被称为重定位（Relocation），这个过程形象一些来说很像拼图：由于模块 1 用到了模块 2 的内容，因此二者分别相当于一块凹进和凸出一部分的拼图，正因如此我们可以将它们无缝地拼接到一起。</p>
</li>
</ul>
<p>上面我们简单介绍了程序内存布局和编译流程特别是链接过程的相关知识。那么如何得到一个能够在 Qemu 上成功运行的内核镜像呢？首先我们需要通过链接脚本调整内核可执行文件的内存布局，使得内核被执行的第一条指令位于地址 <code>0x80200000</code> 处，同时代码段所在的地址应低于其他段。这是因为 Qemu 物理内存中低于 <code>0x80200000</code> 的区域并未分配给内核，而是主要由 RustSBI 使用。其次，我们需要将内核可执行文件中的元数据丢掉得到内核镜像，此内核镜像仅包含实际会用到的代码和数据。这则是因为 Qemu 的加载功能过于简单直接，它直接将输入的文件逐字节拷贝到物理内存中，因此也可以说这一步是我们在帮助 Qemu 手动将可执行文件加载到物理内存中。下一节我们将成功生成内核镜像并在 Qemu 上验证控制权被转移到内核。</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2环境配置</title>
    <url>/OS/tuos/WSL2%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="arch-Linux"><a href="#arch-Linux" class="headerlink" title="arch Linux"></a>arch Linux</h2><h3 id="WSL2"><a href="#WSL2" class="headerlink" title="WSL2"></a>WSL2</h3><h4 id="1-勾选适用于Linux的Windows子系统后重启"><a href="#1-勾选适用于Linux的Windows子系统后重启" class="headerlink" title="1.勾选适用于Linux的Windows子系统后重启"></a>1.勾选适用于Linux的Windows子系统<strong>后</strong>重启</h4><p><strong>打开“控制面板”-&gt;点击”程序”-&gt;点击“程序和功能”-&gt;点击“启用或关闭 Windows 功能”-&gt; 选中“适用于 Linux 的 Windows 子系统”-&gt;选择”立即重新启动”</strong></p>
<h4 id="2-启用虚拟机功能"><a href="#2-启用虚拟机功能" class="headerlink" title="2.启用虚拟机功能"></a>2.启用虚拟机功能</h4><p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要<a href="https://learn.microsoft.com/zh-cn/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed">虚拟化功能</a>才能使用此功能。</p>
<p>以管理员身份打开 PowerShell 并运行：</p>
<p><strong>点击“开始”-&gt;搜索“Power shell”-&gt;右键“Power shell”-&gt;已管理员方式运行</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>

<p>此处最好重启一下不然后续启动arch Linux时会报错<strong>error: 0x8004032d(null)</strong></p>
<h4 id="3-下载Linux内核更新包"><a href="#3-下载Linux内核更新包" class="headerlink" title="3.下载Linux内核更新包"></a>3.下载Linux内核更新包</h4><p>从<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">官网</a>下载最新的Linux内核更新包并<strong>安装</strong>；</p>
<p><strong>管理员</strong>身份打开PowerShell：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; wsl.exe <span class="literal">--update</span></span><br><span class="line">正在检查更新。</span><br><span class="line">已安装最新版本的适用于 Linux 的 Windows 子系统。</span><br></pre></td></tr></table></figure>

<p>这里如果安装进度一直为0.0%可以试下开启科学上网；</p>
<h4 id="4-将WSL2设置为默认版本"><a href="#4-将WSL2设置为默认版本" class="headerlink" title="4.将WSL2设置为默认版本"></a>4.将WSL2设置为默认版本</h4><p>打开 PowerShell运行以下命令，将 WSL 2 设置为默认版本：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; wsl <span class="literal">--set-default-version</span> <span class="number">2</span></span><br><span class="line">有关与 WSL <span class="number">2</span> 关键区别的信息，请访问 https://aka.ms/wsl2</span><br><span class="line">操作成功完成。</span><br></pre></td></tr></table></figure>

<h4 id="5-安装所选的Linux分发"><a href="#5-安装所选的Linux分发" class="headerlink" title="5.安装所选的Linux分发"></a>5.安装所选的Linux分发</h4><p>打开 <a href="https://aka.ms/wslstore">Microsoft Store</a>，并选择你偏好的 Linux 分发版。（我这里使用的是arch Linux）</p>
<p>首次启动新安装的 Linux 分发版时，将打开一个控制台窗口，系统会要求你等待一分钟或两分钟，以便文件解压缩并存储到电脑上。</p>
<p>然后，需要<a href="https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment#set-up-your-linux-username-and-password">为新的 Linux 分发版创建用户帐户和密码</a>。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Installing,this may take a few minutes...</span><br><span class="line">Iainstallation successful!</span><br><span class="line">Please create a default UNIX user account, The username does not needor to match your windows username.</span><br><span class="line"><span class="keyword">For</span> more information visit: https://aka.ms/wslusers</span><br><span class="line">Enter new UNIX username:</span><br></pre></td></tr></table></figure>

<p>这里要关掉科学上网，不然<strong>Microsoft Store</strong>可能会打不开；</p>
<h4 id="6-查看当前环境的wsl版本和对应子系统"><a href="#6-查看当前环境的wsl版本和对应子系统" class="headerlink" title="6.查看当前环境的wsl版本和对应子系统"></a>6.查看当前环境的wsl版本和对应子系统</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">// 在Windows终端中键入</span><br><span class="line">&gt; wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br><span class="line">  NAME    STATE           VERSION</span><br><span class="line">* Arch    Running         <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="7-注销安装的Linux子系统账户"><a href="#7-注销安装的Linux子系统账户" class="headerlink" title="7.注销安装的Linux子系统账户"></a>7.注销安装的Linux子系统账户</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&gt; wsl <span class="literal">--unregister</span> Arch</span><br></pre></td></tr></table></figure>

<p>（名称要与wsl -l -v 命令中NAME一致）</p>
<h4 id="8-删除安装的Linux子系统"><a href="#8-删除安装的Linux子系统" class="headerlink" title="8.删除安装的Linux子系统"></a>8.删除安装的Linux子系统</h4><p>此电脑-&gt;应用 -&gt; 安装的应用 删除Arch WSL。</p>
<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syyu // 防止软件库更新导致某些功能无法使用</span><br><span class="line">sudo pacman -S neovim</span><br><span class="line">sudo nvim /etc/pacman.conf 尾部添加</span><br><span class="line"></span><br><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Never</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/$repo/$arch</span><br><span class="line"></span><br><span class="line">顺便开启</span><br><span class="line">[multilib]</span><br><span class="line">Include = /etc/pacman.d/mirrorlist</span><br><span class="line"></span><br><span class="line">sudo pacman -Syyu</span><br><span class="line">sudo pacman -S yay</span><br></pre></td></tr></table></figure>

<h2 id="c-Rust-环境配置"><a href="#c-Rust-环境配置" class="headerlink" title="c&#x2F;Rust 环境配置"></a>c&#x2F;Rust 环境配置</h2><h4 id="1-更新-同步arch-Linux内核"><a href="#1-更新-同步arch-Linux内核" class="headerlink" title="1.更新&#x2F;同步arch Linux内核"></a>1.更新&#x2F;同步arch Linux内核</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure>

<p><strong>这里cmd中需要管理员模式启动</strong>（WSL2中不要开梯子）</p>
<h4 id="2-C开发环境配置"><a href="#2-C开发环境配置" class="headerlink" title="2.C开发环境配置"></a>2.C开发环境配置</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sudo pacman -S git base-devel riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-emulators-full riscv64-elf-gdb</span><br></pre></td></tr></table></figure>

<h4 id="3-Rust开发环境配置"><a href="#3-Rust开发环境配置" class="headerlink" title="3.Rust开发环境配置"></a>3.Rust开发环境配置</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">curl --proto &#x27;=https&#x27; --tlsv1.<span class="number">2</span> -sSf https:<span class="comment">//sh.rustup.rs | sh</span></span><br></pre></td></tr></table></figure>

<p>测试是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo --version // 如果cargo无效则重新打开终端进入Linux即可</span></span><br><span class="line">cargo 1.77.1 (e52e36006 2024-03-26)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version</span></span><br><span class="line">rustc 1.77.1 (7cf61ebde 2024-03-27)</span><br></pre></td></tr></table></figure>

<p>切换 nightly 版本，并设置为 rustc 的缺省版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup install nightly</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup default nightly</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustc --version</span></span><br><span class="line">rustc 1.79.0-nightly (385fa9d84 2024-04-04)</span><br></pre></td></tr></table></figure>

<p>安装一些Rust相关的软件包:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup target add riscv64gc-unknown-none-elf</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo install cargo-binutils</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add llvm-tools-preview</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rustup component add rust-src</span></span><br></pre></td></tr></table></figure>

<h2 id="Qemu模拟器"><a href="#Qemu模拟器" class="headerlink" title="Qemu模拟器"></a>Qemu模拟器</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S qemu</span><br></pre></td></tr></table></figure>

<p>三个选择：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)qemu-base   2)qemu-desktop   3)qemu-full</span><br></pre></td></tr></table></figure>

<p>第一个提示中提示中选择<code>3</code>，第二个提示默认<code>1</code>即可。</p>
<h4 id="确认-QEMU-的版本："><a href="#确认-QEMU-的版本：" class="headerlink" title="确认 QEMU 的版本："></a>确认 QEMU 的版本：</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-riscv64 --version</span></span><br><span class="line">QEMU emulator version 9.0.0</span><br><span class="line">Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 --version</span></span><br><span class="line">qemu-riscv64 version 9.0.0</span><br><span class="line">Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>获取代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/rcore-os/rCore-Tutorial-v3.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> rCore-Tutorial-v3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout ch1</span></span><br></pre></td></tr></table></figure>

<p>在Qemu模拟的计算机上运行: （第一次可能会有些很慢）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> os</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LOG=TRACE make run</span></span><br><span class="line"></span><br><span class="line">(rustup target list | grep &quot;riscv64gc-unknown-none-elf (installed)&quot;) || rustup target add riscv64gc-unknown-none-elf</span><br><span class="line">riscv64gc-unknown-none-elf (installed)</span><br><span class="line">cargo install cargo-binutils</span><br><span class="line">    Updating crates.io index</span><br><span class="line">     Ignored package `cargo-binutils v0.3.6` is already installed, use --force to override</span><br><span class="line">rustup component add rust-src</span><br><span class="line">info: component &#x27;rust-src&#x27; is up to date</span><br><span class="line">rustup component add llvm-tools-preview</span><br><span class="line">info: component &#x27;llvm-tools&#x27; for target &#x27;x86_64-unknown-linux-gnu&#x27; is up to date</span><br><span class="line">Platform: qemu</span><br><span class="line">    Finished release [optimized + debuginfo] target(s) in 0.00s</span><br><span class="line">[rustsbi] RustSBI version 0.3.1, adapting to RISC-V SBI v1.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--&#x27;  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87e00000..0x87e010f6</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">[kernel] Hello, world!</span><br><span class="line">[TRACE] [kernel] .text [0x80200000, 0x80202000)</span><br><span class="line">[DEBUG] [kernel] .rodata [0x80202000, 0x80203000)</span><br><span class="line">[ INFO] [kernel] .data [0x80203000, 0x80204000)</span><br><span class="line">[ WARN] [kernel] boot_stack top=bottom=0x80214000, lower_bound=0x80204000</span><br><span class="line">[ERROR] [kernel] .bss [0x80214000, 0x80215000)</span><br></pre></td></tr></table></figure>

<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>1.当你在wsl2环境下运行<code>code</code>命令时报错<code>-bash: code: command not found</code>时：</p>
<ul>
<li>在vscode中安装<code>Remote Development</code>扩展包。</li>
<li>设置Windows下环境变量<code>D:\tools\IDE\VSCode\VSCode\bin</code>(一定要到bin下)</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Rust</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>实现批处理系统</title>
    <url>/OS/tuos/%E5%AE%9E%E7%8E%B0%E6%89%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h1><p>管理无需或仅需少量用户交互即可运行的程序，在资源允许的情况下它可以自动安排程序的执行。</p>
<p>核心思想为：将多个程序打包到一起输入计算机。而当一个程序运行结束后，计算机会 <em>自动</em> 加载下一个程序到内存并开始执行。</p>
<h2 id="特权级机制"><a href="#特权级机制" class="headerlink" title="特权级机制"></a>特权级机制</h2><ul>
<li><p><em>保护</em> 计算机系统不受有意或无意出错的程序破坏的机制被称为 <strong>特权级</strong> (Privilege) 机制。</p>
<ul>
<li>应用程序不能执行某些可能破坏计算机系统的指令</li>
</ul>
</li>
<li><p>它让应用程序运行在<strong>用户态</strong>，而操作系统运行在<strong>内核态</strong>，且实现用户态和内核态的隔离。</p>
<ul>
<li>处理器设置两个不同安全等级的执行环境：<strong>用户态特权级的执行环境</strong>和<strong>内核态特权级的执行环境</strong>。且明确指出可能破坏计算机系统的内核态特权级指令子集，规定内核态特权级指令子集中的指令只能在内核态特权级的执行环境中执行。处理器在执行指令前会进行特权级安全检查，如果在用户态执行环境中执行这些内核态特权级指令，会产生异常。</li>
</ul>
</li>
<li><p>软硬件协同工作。</p>
</li>
</ul>
<h2 id="模拟客户端应用程序"><a href="#模拟客户端应用程序" class="headerlink" title="模拟客户端应用程序"></a>模拟客户端应用程序</h2><h3 id="创建应用端库"><a href="#创建应用端库" class="headerlink" title="创建应用端库"></a>创建应用端库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tuos/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo new user -lib</span></span><br><span class="line">    Creating library `user` package</span><br><span class="line">note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br></pre></td></tr></table></figure>

<p>修改库名</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tuos/user/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;user_lib&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;Kay &lt;cn.kay.wang@gmail.com&gt;&quot;</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span> <span class="comment"># 这里要改不然后续执行会报错</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">riscv</span> = &#123; git = <span class="string">&quot;https://github.com/rcore-os/riscv&quot;</span>, features = [<span class="string">&quot;inline-asm&quot;</span>] &#125; </span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span> <span class="comment"># 因qemu9.0.0兼容性文件所以要设置</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 <code>lib.rs</code> 中我们定义了用户库的入口点 <code>_start</code> </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将属性宏从指定库中导入到当前作用域中</span></span><br><span class="line"><span class="keyword">use</span> user_lib::println;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不修改符号名</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="comment">// 指定.text.entry段入口</span></span><br><span class="line"><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>());</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;unreachable after sys_exit!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还在 <code>lib.rs</code> 中看到了另一个 <code>main</code> </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标为弱链接，虽然名叫main但不会作为主函数</span></span><br><span class="line"><span class="meta">#[linkage = <span class="string">&quot;weak&quot;</span>]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Cannot find main!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了支持上述这些链接操作，我们需要在 <code>lib.rs</code> 的开头加入</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># tuos/user/lib.rs</span><br><span class="line"></span><br><span class="line"><span class="meta">#![feature(linkage)]</span></span><br></pre></td></tr></table></figure>

<h3 id="设置内存布局"><a href="#设置内存布局" class="headerlink" title="设置内存布局"></a>设置内存布局</h3><p>让操作系统能够把应用加载到内存地址，然后顺利启动并运行应用程序。</p>
<ul>
<li><p>在 <code>user/.cargo/config</code> 中，设置链接时使用链接脚本 <code>user/src/linker.ld</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user/.cargo/config</span></span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line">target = &quot;riscv64gc-unknown-none-elf&quot;</span><br><span class="line"></span><br><span class="line">[target.riscv64gc-unknown-none-elf]</span><br><span class="line">rustflags = [</span><br><span class="line">    &quot;-Clink-args=-Tsrc/linker.ld&quot;, &quot;-Cforce-frame-pointers=yes&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置内存布局</p>
<ul>
<li>在<code>user/src/linker.ld</code>中设置程序起始地址为<code>0x80400000</code>；</li>
<li>将 <code>_start</code> 所在的 <code>.text.entry</code> 放在整个程序的开头，使得系统只要跳转到<code>0x80400000</code>就已经进入了 用户库的入口点，并会在初始化之后跳转到应用程序主逻辑；</li>
<li>提供了最终生成可执行文件的 <code>.bss</code> 段的起始和终止地址，方便 <code>clear_bss</code> 函数使用；</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user/src/linker.ld</span></span><br><span class="line"></span><br><span class="line">OUTPUT_ARCH(riscv)</span><br><span class="line">ENTRY(_start)</span><br><span class="line"></span><br><span class="line">BASE_ADDRESS = 0x80400000;</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    . = BASE_ADDRESS;</span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text.entry)</span><br><span class="line">        *(.text .text.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .rodata : &#123;</span><br><span class="line">        *(.rodata .rodata.*)</span><br><span class="line">        *(.srodata .srodata.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .data : &#123;</span><br><span class="line">        *(.data .data.*)</span><br><span class="line">        *(.sdata .sdata.*)</span><br><span class="line">    &#125;</span><br><span class="line">    .bss : &#123;</span><br><span class="line">        start_bss = .;</span><br><span class="line">        *(.bss .bss.*)</span><br><span class="line">        *(.sbss .sbss.*)</span><br><span class="line">        end_bss = .;</span><br><span class="line">    &#125;</span><br><span class="line">    /DISCARD/ : &#123;</span><br><span class="line">        *(.eh_frame)</span><br><span class="line">        *(.debug*)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="调用系统ABI"><a href="#调用系统ABI" class="headerlink" title="调用系统ABI"></a>调用系统ABI</h3><p>使用RISC-V 提供的机器指令：执行环境调用指令（Execution Environment Call，简称 <code>ecall</code> ）和一类执行环境返回（Execution Environment Return，简称 <code>eret</code> ）指令。其中：</p>
<ul>
<li><code>ecall</code> 具有用户态到内核态的执行环境切换能力的函数调用指令；</li>
<li><code>sret</code> ：具有内核态到用户态的执行环境切换能力的函数返回指令。</li>
</ul>
<p>这里约定如下两个系统调用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 功能：将内存中缓冲区中的数据写入文件。</span></span><br><span class="line"><span class="comment">/// 参数：`fd` 表示待写入文件的文件描述符；</span></span><br><span class="line"><span class="comment">///      `buf` 表示内存中缓冲区的起始地址；</span></span><br><span class="line"><span class="comment">///      `len` 表示内存中缓冲区的长度。</span></span><br><span class="line"><span class="comment">/// 返回值：返回成功写入的长度。</span></span><br><span class="line"><span class="comment">/// syscall ID：64</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buf: *<span class="keyword">const</span> <span class="type">u8</span>, len: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 功能：退出应用程序并将返回值告知批处理系统。</span></span><br><span class="line"><span class="comment">/// 参数：`exit_code` 表示应用程序的返回值。</span></span><br><span class="line"><span class="comment">/// 返回值：该系统调用不应该返回。</span></span><br><span class="line"><span class="comment">/// syscall ID：93</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sys_exit</span>(exit_code: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> !;</span><br></pre></td></tr></table></figure>

<p>由于rust不直接支持寄存器操作，为此我们需要在代码中使用内嵌汇编来完成参数&#x2F;返回值绑定和 <code>ecall</code> 指令的插入：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::arch::asm;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>: <span class="type">isize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// asm! 宏可以将汇编代码嵌入到局部的函数上下文中。</span></span><br><span class="line">        <span class="comment">// 相比 global_asm!, asm! 宏可以获取上下文中的变量信息并允许嵌入的汇编代码对这些变量进行操作</span></span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将所有的系统调用都封装成 <code>syscall</code> 函数。</p>
<blockquote>
<p>在 RISC-V 调用规范中，和函数调用的 ABI 情形类似，约定寄存器 <code>a0~a6</code> 保存系统调用的参数， <code>a0</code> 保存系统调用的返回值。有些许不同的是寄存器 <code>a7</code> 用来传递 syscall ID，这是因为所有的 syscall 都是通过 <code>ecall</code> 指令触发的，除了各输入参数之外我们还额外需要一个寄存器来保存要请求哪个系统调用。</p>
<p><strong>RISC-V 寄存器编号和别名</strong></p>
<p>RISC-V 寄存器编号从 <code>0~31</code> ，表示为 <code>x0~x31</code> 。 其中：</p>
<ul>
<li><code>x10~x17</code> : 对应 <code>a0~a7</code></li>
<li><code>x1</code> ：对应 <code>ra</code></li>
</ul>
<p>在 <code>ecall</code> 指令中<code>a0~a2</code> 和 <code>a7</code> 作为输入寄存器分别表示系统调用参数和系统调用 ID，当系统调用返回后， <code>a0</code> 作为输出寄存器保存系统调用的返回值。</p>
</blockquote>
<p>于是 <code>sys_write</code> 和 <code>sys_exit</code> 只需将 <code>syscall</code> 进行包装：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/syscall.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buffer: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_WRITE, [fd, buffer.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, buffer.<span class="title function_ invoke__">len</span>()])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述两个系统调用在用户库 <code>user_lib</code> 中进一步封装，从而更加接近在 Linux 等平台的实际系统调用接口：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> syscall::*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write</span>(fd: <span class="type">usize</span>, buf: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_write</span>(fd, buf) &#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exit</span>(exit_code: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123; <span class="title function_ invoke__">sys_exit</span>(exit_code) &#125;</span><br></pre></td></tr></table></figure>

<p>将 <code>console</code> 子模块中 <code>Stdout::write_str</code> 改成基于 <code>write</code> 的实现，且传入的 <code>fd</code> 参数设置为 1，它代表标准输出， 也就是输出到屏幕。目前我们不需要考虑其他的 <code>fd</code> 选取情况。这样，应用程序的 <code>println!</code> 宏借助系统调用变得可用了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/src/console.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> STDOUT: <span class="type">usize</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">write</span>(STDOUT, s.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exit</code> 接口则在用户库中的 <code>_start</code> 内使用，当应用程序主逻辑 <code>main</code> 返回之后，使用它退出应用程序并将返回值告知 底层的批处理系统。</p>
<h3 id="模拟应用程序执行"><a href="#模拟应用程序执行" class="headerlink" title="模拟应用程序执行"></a>模拟应用程序执行</h3><p>尝试在用户态模拟器 <code>qemu-riscv64</code> 执行这两个应用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> user</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> target/riscv64gc-unknown-none-elf/release/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认待执行的应用为 ELF 格式</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file 03priv_inst</span></span><br><span class="line">03priv_inst: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, not stripped</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行特权指令出错</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 ./03priv_inst</span></span><br><span class="line">Try to execute privileged instruction in U Mode</span><br><span class="line">Kernel should kill this application!</span><br><span class="line">Illegal instruction (core dumped)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行访问特权级 CSR 的指令出错</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 ./04priv_csr</span></span><br><span class="line">Try to access privileged CSR in U Mode</span><br><span class="line">Kernel should kill this application!</span><br><span class="line">Illegal instruction (core dumped)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>user/Cargo.toml</code>下要设置</p>
<p>[package]</p>
<p>edition &#x3D; “2018”</p>
<p>[profile.release]</p>
<p>5 1  0opt-level &#x3D; 0</p>
<p>不然几个实例客户端程序将可能会出错</p>
</blockquote>
<h2 id="实现批处理系统"><a href="#实现批处理系统" class="headerlink" title="实现批处理系统"></a>实现批处理系统</h2><ul>
<li>操作系统自身运行在内核态，支持应用程序在用户态运行，且能够完成应用程序发出的系统调用。</li>
<li>能够一个接着一个地自动运行不同的运行程序</li>
</ul>
<p>在具体实现其批处理执行应用程序功能之前，本节我们首先实现该应用加载机制，也即：在操作系统和应用程序需要被放置到同一个可执行文件的前提下，设计一种尽量简洁的应用放置和加载方式，使得操作系统容易找到应用被放置到的位置，从而在批处理操作系统和应用程序之间建立起联系的纽带。具体而言，应用放置采用“静态绑定”的方式，而操作系统加载应用则采用“动态加载”的方式：</p>
<ul>
<li>静态绑定：通过一定的编程技巧，把多个应用程序代码和批处理操作系统代码“绑定”在一起。</li>
<li>动态加载：基于静态编码留下的“绑定”信息，操作系统可以找到每个应用程序文件二进制代码的起始地址和长度，并能加载到内存中运行。</li>
</ul>
<h3 id="将应用程序链接到内核"><a href="#将应用程序链接到内核" class="headerlink" title="将应用程序链接到内核"></a>将应用程序链接到内核</h3><p>利用<code>build.rs</code>脚本文件生成汇编代码将应用程序链接到内核</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/build.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fs::&#123;read_dir, File&#125;;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="type">Result</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=../user/src/&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;cargo:rerun-if-changed=&#123;&#125;&quot;</span>, TARGET_PATH);</span><br><span class="line">    <span class="title function_ invoke__">insert_app_data</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> TARGET_PATH: &amp;<span class="type">str</span> = <span class="string">&quot;../user/target/riscv64gc-unknown-none-elf/release/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">insert_app_data</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;src/link_app.S&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">apps</span>: <span class="type">Vec</span>&lt;_&gt; = <span class="title function_ invoke__">read_dir</span>(<span class="string">&quot;../user/src/bin&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">into_iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|dir_entry| &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">name_with_ext</span> = dir_entry.<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">file_name</span>().<span class="title function_ invoke__">into_string</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            name_with_ext.<span class="title function_ invoke__">drain</span>(name_with_ext.<span class="title function_ invoke__">find</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">unwrap</span>()..name_with_ext.<span class="title function_ invoke__">len</span>());</span><br><span class="line">            name_with_ext</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    apps.<span class="title function_ invoke__">sort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">writeln!</span>(</span><br><span class="line">        f,</span><br><span class="line">        <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">    .align 3</span></span><br><span class="line"><span class="string">    .section .data</span></span><br><span class="line"><span class="string">    .global _num_app</span></span><br><span class="line"><span class="string">_num_app:</span></span><br><span class="line"><span class="string">    .quad &#123;&#125;&quot;#</span>,</span><br><span class="line">        apps.<span class="title function_ invoke__">len</span>()</span><br><span class="line">    )?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..apps.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        <span class="built_in">writeln!</span>(f, <span class="string">r#&quot;    .quad app_&#123;&#125;_start&quot;#</span>, i)?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">writeln!</span>(f, <span class="string">r#&quot;    .quad app_&#123;&#125;_end&quot;#</span>, apps.<span class="title function_ invoke__">len</span>() - <span class="number">1</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx, app) <span class="keyword">in</span> apps.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;app_&#123;&#125;: &#123;&#125;&quot;</span>, idx, app);</span><br><span class="line">        <span class="built_in">writeln!</span>(</span><br><span class="line">            f,</span><br><span class="line">            <span class="string">r#&quot;</span></span><br><span class="line"><span class="string">    .section .data</span></span><br><span class="line"><span class="string">    .global app_&#123;0&#125;_start</span></span><br><span class="line"><span class="string">    .global app_&#123;0&#125;_end</span></span><br><span class="line"><span class="string">app_&#123;0&#125;_start:</span></span><br><span class="line"><span class="string">    .incbin &quot;&#123;2&#125;&#123;1&#125;.bin&quot;</span></span><br><span class="line"><span class="string">app_&#123;0&#125;_end:&quot;#</span>,</span><br><span class="line">            idx, app, TARGET_PATH</span><br><span class="line">        )?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>build.rs</code>脚本文件将生成以下类似文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># os/src/link_app.S</span><br><span class="line"></span><br><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line">_num_app:</span><br><span class="line">    .quad 5</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_2_start</span><br><span class="line">    .quad app_3_start</span><br><span class="line">    .quad app_4_start</span><br><span class="line">    .quad app_4_end</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">app_0_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin&quot;</span><br><span class="line">app_0_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_1_start</span><br><span class="line">    .global app_1_end</span><br><span class="line">app_1_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin&quot;</span><br><span class="line">app_1_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_2_start</span><br><span class="line">    .global app_2_end</span><br><span class="line">app_2_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/02power.bin&quot;</span><br><span class="line">app_2_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_3_start</span><br><span class="line">    .global app_3_end</span><br><span class="line">app_3_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/03priv_inst.bin&quot;</span><br><span class="line">app_3_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_4_start</span><br><span class="line">    .global app_4_end</span><br><span class="line">app_4_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/04priv_csr.bin&quot;</span><br><span class="line">app_4_end:</span><br></pre></td></tr></table></figure>

<p>将汇编代码链接到内核</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"># os/src/main.rs</span><br><span class="line"></span><br><span class="line">global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;link_app.S&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="找到并加载应用程序二进制码"><a href="#找到并加载应用程序二进制码" class="headerlink" title="找到并加载应用程序二进制码"></a>找到并加载应用程序二进制码</h3><p>创建一个<em>应用管理器</em><code>AppManager</code>用来找到并加载应用程序二进制码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppManager</span> &#123;</span><br><span class="line">    num_app: <span class="type">usize</span>,</span><br><span class="line">    current_app: <span class="type">usize</span>,</span><br><span class="line">    app_start: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中：</p>
<ul>
<li><code>current_app</code> 字段表示当前执行的是第几个应用，它是一个可修改的变量，会在系统运行期间发生变化。</li>
</ul>
</blockquote>
<p>我们希望将 <code>AppManager</code> 实例化为一个全局变量，使得任何函数都可以直接访问，最简单就是将它设置为<code>static mut</code>，但<code>static mut</code>则是 unsafe 的，而我们要在编程中尽量避免使用 unsafe ，这样才能让编译器负责更多的安全性检查。因此，我们需要使用<code>RefCell</code>，即内部可变性。但要给<code>static</code>类型的变量设置<code>RefCell</code>则必须要实现<code>Sync</code> tarit。为此我们在<code>RefCell</code>上封装一层叫做<code>UPSafeCell</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/sync/up.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">UPSafeCell</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// inner data</span></span><br><span class="line">    inner: RefCell&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">UPSafeCell</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; UPSafeCell&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/// User is responsible to guarantee that inner struct is only used in</span></span><br><span class="line">    <span class="comment">/// uniprocessor.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; inner: RefCell::<span class="title function_ invoke__">new</span>(value) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Panic if the data has been borrowed.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exclusive_access</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> RefMut&lt;<span class="symbol">&#x27;_</span>, T&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.inner.<span class="title function_ invoke__">borrow_mut</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UPSafeCell</code> 对于 <code>RefCell</code> 简单进行封装，它和 <code>RefCell</code> 一样提供内部可变性和运行时借用检查，只是更加严格：调用 <code>exclusive_access</code> 可以得到它包裹的数据的独占访问权。因此当我们要访问数据时（无论读还是写），需要首先调用 <code>exclusive_access</code> 获得数据的可变借用标记，通过它可以完成数据的读写，在操作完成之后我们需要销毁这个标记，此后才能开始对该数据的下一次访问。相比 <code>RefCell</code> 它不再允许多个读操作同时存在。</p>
<p>这段代码里面出现了两个 <code>unsafe</code> ：</p>
<ul>
<li>首先 <code>new</code> 被声明为一个 <code>unsafe</code> 函数，是因为我们希望使用者在创建一个 <code>UPSafeCell</code> 的时候保证在访问 <code>UPSafeCell</code> 内包裹的数据的时候始终不违背上述模式：即访问之前调用 <code>exclusive_access</code> ，访问之后销毁借用标记再进行下一次访问。这只能依靠使用者自己来保证，但我们提供了一个保底措施：当使用者违背了上述模式，比如访问之后忘记销毁就开启下一次访问时，程序会 panic 并退出。<code>unsafe</code> 关键字本身无法提供上述保障，这个关键字主要是给用户一个警告和提示。这个保证在单核的情况下可以由借用检查器给到。</li>
<li>另一方面，我们将 <code>UPSafeCell</code> 标记为 <code>Sync</code> 使得它可以作为一个全局变量。这是 unsafe 行为，因为编译器无法确定我们的 <code>UPSafeCell</code> 能否安全的在多线程间共享。而我们能够向编译器做出保证，第一个原因是目前我们内核仅运行在单核上，因此无需在意任何多核引发的数据竞争&#x2F;同步问题；第二个原因则是它基于 <code>RefCell</code> 提供了运行时借用检查功能，从而满足了 Rust 对于借用的基本约束进而保证了内存安全。</li>
</ul>
<p>初始化<code>AppManager</code>的全局实例<code>APP_MANAGER</code></p>
<p>这里我们使用了外部库 <code>lazy_static</code> 提供的 <code>lazy_static!</code> 宏。</p>
<p>添加依赖</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># os/Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">lazy_static</span> = &#123; version = <span class="string">&quot;1.4.0&quot;</span>, features = [<span class="string">&quot;spin_no_std&quot;</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>lazy_static!</code> 宏进行初始化工作</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os/src/batch.rs</span></span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> APP_MANAGER: UPSafeCell&lt;AppManager&gt; = <span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(&#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; <span class="keyword">fn</span> <span class="title function_">_num_app</span>(); &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num_app_ptr</span> = _num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">num_app</span> = num_app_ptr.<span class="title function_ invoke__">read_volatile</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_start</span>: [<span class="type">usize</span>; MAX_APP_NUM + <span class="number">1</span>] = [<span class="number">0</span>; MAX_APP_NUM + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">app_start_raw</span>: &amp;[<span class="type">usize</span>] =  core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">            num_app_ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>), num_app + <span class="number">1</span></span><br><span class="line">        );</span><br><span class="line">        app_start[..=num_app].<span class="title function_ invoke__">copy_from_slice</span>(app_start_raw);</span><br><span class="line">        AppManager &#123;</span><br><span class="line">            num_app,</span><br><span class="line">            current_app: <span class="number">0</span>,</span><br><span class="line">            app_start,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现跨特权级的系统接口调用"><a href="#实现跨特权级的系统接口调用" class="headerlink" title="实现跨特权级的系统接口调用"></a>实现跨特权级的系统接口调用</h3><h3 id="执行系统调用前后能够准备和恢复用户态执行应用程序的上下文"><a href="#执行系统调用前后能够准备和恢复用户态执行应用程序的上下文" class="headerlink" title="执行系统调用前后能够准备和恢复用户态执行应用程序的上下文"></a>执行系统调用前后能够准备和恢复用户态执行应用程序的上下文</h3><h3 id="支持多个应用程序轮流启动运行"><a href="#支持多个应用程序轮流启动运行" class="headerlink" title="支持多个应用程序轮流启动运行"></a>支持多个应用程序轮流启动运行</h3><h2 id="二者之间的特权级切换"><a href="#二者之间的特权级切换" class="headerlink" title="二者之间的特权级切换"></a>二者之间的特权级切换</h2><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2>]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中软件的暗转与构建</title>
    <url>/Linux/BasicOperations/%E5%AE%89%E8%A3%85%E4%B8%8E%E6%9E%84%E5%BB%BA%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>直接使用对应Linux发行版的包管理工具(apt、yum、def、pacman)等。</p>
<h1 id="构建并安装"><a href="#构建并安装" class="headerlink" title="构建并安装"></a>构建并安装</h1><p><strong>1. 获取&#x2F;编写源代码</strong></p>
<p><strong>2. 准备构建环境&#x2F;安装构建工具</strong></p>
<p><strong>3. 编译源代码</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust基础</title>
    <url>/Rust/basic/Rust%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Rust-编译期计算"><a href="#Rust-编译期计算" class="headerlink" title="Rust 编译期计算"></a>Rust 编译期计算</h2><p><em>CTFE</em>(compile time function evaluation)：是指在编译阶段由编译器进行的运算，这种运算不占用程序运行时的时间。</p>
<p>两种方式：</p>
<ul>
<li><p>过程宏 + Build脚本(build.rs)</p>
</li>
<li><p>常量表达式求值</p>
<ul>
<li>常量函数(const fn)</li>
<li>常量泛型(const generic)</li>
</ul>
</li>
</ul>
<p><strong>常量传播</strong>：常量传播是编译器的一种优化方式，例如将3 + 4 优化为 7 ，避免运行时再次计算。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> X: <span class="type">u32</span> = <span class="number">3</span> + <span class="number">4</span>; <span class="comment">// CTEF</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = <span class="number">3</span> + <span class="number">4</span>; <span class="comment">// 不是 CTEF,但可能会被常量传播优化，因为他不在常量上下文。</span></span><br></pre></td></tr></table></figure>

<h3 id="常量表达式求值"><a href="#常量表达式求值" class="headerlink" title="常量表达式求值"></a>常量表达式求值</h3><p><strong>常量函数</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">fib</span>(n: <span class="type">u128</span>) <span class="punctuation">-&gt;</span> <span class="type">u128</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">helper</span>(n: <span class="type">u128</span>, a: <span class="type">u128</span>, b: <span class="type">u128</span>, i: <span class="type">u128</span>) <span class="punctuation">-&gt;</span> <span class="type">u128</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt;= n &#123;</span><br><span class="line">            <span class="title function_ invoke__">helper</span>(n, b, a + b, i + <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">helper</span>(n, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> X: <span class="type">u128</span> = <span class="title function_ invoke__">filb</span>(<span class="number">10</span>); <span class="comment">// X 会在编译器完成求值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, X); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译期计算通过 MIR(中级中间语言) 中内置的 MIri(编译器内置 MIR 解释器) 实现</p>
</blockquote>
<p><strong>常量泛型</strong></p>
<p>为什么要有常量泛型？</p>
<p>因为在 Rust 中定义相同的静态数组是不同的元素：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二者是不同的类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="number">3</span>; <span class="type">i32</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="number">5</span>; <span class="type">i32</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>为了在使用过程中可以使用泛型统一个的不同长度的数组，官方引入了常量泛型的概念。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::MaybeUninit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">ArrayVec</span>&lt;T, <span class="keyword">const</span> N: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    items: [MaybeUninit&lt;T&gt;; N],</span><br><span class="line">    length: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过程宏-Build脚本-build-rs"><a href="#过程宏-Build脚本-build-rs" class="headerlink" title="过程宏 + Build脚本(build.rs)"></a>过程宏 + Build脚本(build.rs)</h3>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust数据内存布局</title>
    <url>/Rust/basic/Rust%E6%95%B0%E6%8D%AE%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p><strong>整数类型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>最小值</th>
<th>最大值</th>
<th>大小(bytes)</th>
<th>对齐(bytes)</th>
</tr>
</thead>
<tbody><tr>
<td><code>u8</code></td>
<td>0</td>
<td>28-1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>u16</code></td>
<td>0</td>
<td>216-1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><code>u32</code></td>
<td>0</td>
<td>232-1</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>u64</code></td>
<td>0</td>
<td>264-1</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td><code>u128</code></td>
<td>0</td>
<td>2128-1</td>
<td>16</td>
<td>16</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类型</th>
<th>最小值</th>
<th>最大值</th>
<th>大小(bytes)</th>
<th>对齐(bytes)align(bytes)</th>
</tr>
</thead>
<tbody><tr>
<td><code>i8</code></td>
<td>-(27)</td>
<td>27-1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><code>i16</code></td>
<td>-(215)</td>
<td>215-1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td><code>i32</code></td>
<td>-(231)</td>
<td>231-1</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td><code>i64</code></td>
<td>-(263)</td>
<td>263-1</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td><code>i128</code></td>
<td>-(2127)</td>
<td>2127-1</td>
<td>16</td>
<td>16</td>
</tr>
</tbody></table>
<p><strong>浮点数</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小(bytes)</th>
<th>对齐(bytes)</th>
</tr>
</thead>
<tbody><tr>
<td>f32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>f64</td>
<td>8</td>
<td>8</td>
</tr>
</tbody></table>
<p>f64 在 x86 系统上对齐到 4 bytes。</p>
<p><strong>usized &amp; isized</strong></p>
<p>usize 无符号整形，isize 有符号整形。 在 64 位系统上，长度为 8 bytes，在 32 位系统上长度为 4 bytes。</p>
<p><strong>bool</strong></p>
<p>bool 类型，取值为 true 或 false，长度和对齐长度都是 1 byte。</p>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p>数组的内存布局为系统类型元组的有序组合。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">A</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::size_of::&lt;[<span class="type">i32</span>; <span class="number">3</span>]&gt;()); <span class="comment">// 大小: 12</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::align_of::&lt;[<span class="type">i32</span>; <span class="number">3</span>]&gt;()); <span class="comment">// 对齐: 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="str"><a href="#str" class="headerlink" title="str"></a>str</h2><p><strong>char 类型</strong></p>
<p>char 表示：一个 32 位长度字符，Unicode 标量值 <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode Scalar Value</a> 范围为 in the 0x0000 - 0xD7FF 或者是 0xE000 - 0x10FFFF。</p>
<p><strong>str 类型</strong></p>
<p>str 与 [u8] 一样表示一个 u8 的 slice。Rust 中标准库中对 str 有个假设：符合 UTF-8 编码。内存布局与 [u8] 相同。</p>
<blockquote>
<p>[u8]是一个字节切片的类型，而不是一个固定大小的数组。切片是对数组的引用或数组部分的一个动态视图，允许你访问一个连续的内存区域，就像访问一个数组一样，但切片本身并不拥有其引用的数据。</p>
<p><code>[u8; N]</code>：这是一个固定大小的字节数组，其中 <code>N</code> 是数组的长度。例如，<code>[u8; 4]</code> 是一个包含四个 <code>u8</code> 元素的数组。</p>
<p>二者要注意不要搞混了</p>
</blockquote>
<p><strong>slice</strong></p>
<p>slice 是 DST 类型，是类型 T 序列的一种视图。 slice 的使用必须要通过指针，&amp;[T] 是一个胖指针，保存指向<code>数据的地址</code>和<code>元素个数</code>。 <code>slice 的内存布局与其指向的 array 部分相同</code>。</p>
<p><strong>&amp;str 与 String 的区别</strong></p>
<p>下面给出 &amp;str String 的内存结构比对：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_name</span> = <span class="string">&quot;Pascal&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">my_name.<span class="title function_ invoke__">push_str</span>( <span class="string">&quot; Precht&quot;</span>);</span><br><span class="line"><span class="comment">// str</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">last_name</span> = &amp;my_name[<span class="number">7</span>..];</span><br></pre></td></tr></table></figure>

<p>String</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">                     buffer</span><br><span class="line">                   /   capacity</span><br><span class="line">                 /   /  length</span><br><span class="line">               /   /   /</span><br><span class="line">            +–––+–––+–––+</span><br><span class="line">stack frame │ • │ 8 │ 6 │ &lt;- my_name: String</span><br><span class="line">            +–│–+–––+–––+</span><br><span class="line">              │</span><br><span class="line">            [–│–––––––– capacity –––––––––––]</span><br><span class="line">              │</span><br><span class="line">            +–V–+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line">       heap │ P │ a │ s │ c │ a │ l │   │   │</span><br><span class="line">            +–––+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line"></span><br><span class="line">            [––––––– length ––––––––]</span><br></pre></td></tr></table></figure>

<p>String vs &amp;str</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">         my_name: <span class="type">String</span>   last_name: &amp;<span class="type">str</span></span><br><span class="line">            [––––––––––––]    [–––––––]</span><br><span class="line">            +–––+––––+––––+–––+–––+–––+</span><br><span class="line">stack frame │ • │ <span class="number">16</span> │ <span class="number">13</span> │   │ • │ <span class="number">6</span> │  <span class="comment">// &amp;str 没有 capacity</span></span><br><span class="line">            +–│–+––––+––––+–––+–│–+–––+</span><br><span class="line">              │                 │</span><br><span class="line">              │                 +–––––––––+</span><br><span class="line">              │                           │</span><br><span class="line">              │                           │</span><br><span class="line">              │                         [–│––––––– <span class="type">str</span> –––––––––]</span><br><span class="line">            +–V–+–––+–––+–––+–––+–––+–––+–V–+–––+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line">       heap │ P │ a │ s │ c │ a │ l │   │ P │ r │ e │ c │ h │ t │   │   │   │</span><br><span class="line">            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line"></span><br><span class="line">			[––––––––––––––––––––––––––– my_name –––––––––––––––––––––––––––]</span><br><span class="line">										[–––––––––––– last_name ––––––––––––]</span><br></pre></td></tr></table></figure>

<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>结构体是带命名的复合类型，有以下几种</p>
<p><strong>具名结构体</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>元组结构体</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Position</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br></pre></td></tr></table></figure>

<p><strong>单元结构体</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Gamma;</span><br></pre></td></tr></table></figure>

<p><strong>内存布局</strong></p>
<blockquote>
<p>数据对齐</p>
<p>数据对齐是指将数据存储在内存中时，按照特定的规则将数据放置在内存地址上的一种方式。</p>
<p>数据对齐的主要目的是为了提高数据读取效率。当CPU访问正确对齐的数据时，它的运行效率最高。若数据没有对齐，CPU在读取或写入数据时可能需要进行多次操作，这会降低CPU的效率，增加系统的开销。</p>
<p>编译器优化 -&gt; 字段重排</p>
<p>Rust编译器在优化结构体时，可能会进行字段重排（field reordering），这是为了优化内存访问、提高数据缓存的效率，以及确保数据满足平台的内存对齐要求。</p>
<p>Rust编译器的字段重排是一种优化技术，旨在提高程序的性能和内存使用效率。</p>
</blockquote>
<p>Rust 中结构体的对齐属性等于<code>它所有成员中最大的那个</code>。Rust 会在必要的位置填充空白数据，以保证每一个成员都正确地对齐，同时<code>整个类型的尺寸是对齐属性的整数倍</code>。例如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    a: <span class="type">u8</span>, <span class="comment">// 1B</span></span><br><span class="line">    b: <span class="type">u32</span>, <span class="comment">// 4B</span></span><br><span class="line">    c: <span class="type">u16</span>, <span class="comment">// 2B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印下变量地址，可以根据结果看到对齐属性为 4, 结构大小为 8 byte 。</span></span><br><span class="line"><span class="comment">// 1 + 4 + 2 = 7</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = A &#123;</span><br><span class="line">        a: <span class="number">1</span>,</span><br><span class="line">        b: <span class="number">2</span>,</span><br><span class="line">        c: <span class="number">3</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0x&#123;:X&#125; 0x&#123;:X&#125; 0x&#123;:X&#125;&quot;</span>, &amp;a.a <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span> <span class="keyword">as</span> <span class="type">usize</span>, &amp;a.b <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u32</span> <span class="keyword">as</span> <span class="type">usize</span> , &amp;a.c <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u16</span> <span class="keyword">as</span> <span class="type">usize</span> );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::size_of::&lt;A&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0x327EFBF35E</span> <span class="number">0x327EFBF358</span> <span class="number">0x327EFBF35C</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rust编译器会进行内存重排，并填充所需大小(这里是1B)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    b: <span class="type">u32</span>,</span><br><span class="line">    c: <span class="type">u16</span>,</span><br><span class="line">    a: <span class="type">u8</span>,</span><br><span class="line">    _pad: [<span class="type">u8</span>; <span class="number">1</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo1字段顺序：data2(0), count(4), data1(6) </span></span><br><span class="line"><span class="comment">// foo1字段顺序：data1(8), count(c), data2(e) </span></span><br><span class="line"><span class="comment">// 可以看到编译器会改变 Foo&lt;T, U&gt; 中成员顺序。</span></span><br><span class="line"><span class="comment">// 内存优化原则要求不同的范型可以有不同的成员顺序。 如果不优化的可能会造成如下情况，造成大量内存开销：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&lt;<span class="type">u16</span>, <span class="type">u32</span>&gt; &#123;</span><br><span class="line">    count: <span class="type">u16</span>,</span><br><span class="line">    data1: <span class="type">u16</span>,</span><br><span class="line">    data2: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span>&lt;<span class="type">u32</span>, <span class="type">u16</span>&gt; &#123;</span><br><span class="line">    count: <span class="type">u16</span>,</span><br><span class="line">    _pad1: <span class="type">u16</span>,</span><br><span class="line">    data1: <span class="type">u32</span>,</span><br><span class="line">    data2: <span class="type">u16</span>,</span><br><span class="line">    _pad2: <span class="type">u16</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>元组是匿名的复合类型，有以下几种 tuple：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">() (unit)</span><br><span class="line">(<span class="type">f64</span>, <span class="type">f64</span>)</span><br><span class="line">(<span class="type">String</span>, <span class="type">i32</span>)</span><br><span class="line">(<span class="type">i32</span>, <span class="type">String</span>) (different <span class="keyword">type</span> <span class="title class_">from</span> the previous example)</span><br><span class="line">(<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;, <span class="type">Option</span>&lt;<span class="type">bool</span>&gt;)</span><br></pre></td></tr></table></figure>

<p>tuple 的结构和 Struct 一致，只是元素是通过 index 进行访问的。</p>
<h2 id="closure"><a href="#closure" class="headerlink" title="closure"></a>closure</h2><p>闭包相当于一个捕获变量的结构体，实现了<code>FnOnce</code>或<code>FnMut</code>或<code>Fn</code>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">f</span>&lt;F : <span class="title function_ invoke__">FnOnce</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span>&gt; (g: F) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">g</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">f</span>(|| &#123;</span><br><span class="line">    s += &amp;t;</span><br><span class="line">    s</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Prints &quot;foobar&quot;.</span></span><br></pre></td></tr></table></figure>



<h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><h2 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h2><h2 id="Dynamically-Sized-Types-DST"><a href="#Dynamically-Sized-Types-DST" class="headerlink" title="Dynamically Sized Types(DST)"></a>Dynamically Sized Types(DST)</h2><h2 id="零大小类型-ZST-Zero-Sized-Type"><a href="#零大小类型-ZST-Zero-Sized-Type" class="headerlink" title="零大小类型(ZST, Zero Sized Type)"></a>零大小类型(ZST, Zero Sized Type)</h2><h2 id="空类型-Empty-Types"><a href="#空类型-Empty-Types" class="headerlink" title="空类型(Empty Types)"></a>空类型(Empty Types)</h2><h2 id="数据布局"><a href="#数据布局" class="headerlink" title="数据布局"></a>数据布局</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust版本概述</title>
    <url>/Rust/basic/Rust%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>Rust语言的版本主要包括<code>语义化版本</code>、<code>发行版本</code>、<code>Edition版次</code>三个相互正交的概念。</p>
<h1 id="语义化版本"><a href="#语义化版本" class="headerlink" title="语义化版本"></a>语义化版本</h1><ul>
<li><p>格式：主版本号.次版本号.修订号，以此用 . 隔开</p>
<p>主版本号：当做了不兼容的 API 修改。</p>
<p>次版本号：当做了向下兼容的功能性递增。</p>
<p>修订号：   当做了向下兼容的问题修正。</p>
</li>
</ul>
<h1 id="发行版本"><a href="#发行版本" class="headerlink" title="发行版本"></a>发行版本</h1><p>master -&gt; Nightly：开发版；</p>
<p>bata -&gt; Beta：测试版；</p>
<p>stable -&gt; Stable：稳定版；</p>
<h1 id="Edition版次"><a href="#Edition版次" class="headerlink" title="Edition版次"></a>Edition版次</h1><p>版次的意义在于方便<code>Rust</code>自身的进化，保证新的变化不会影响自身原有的生态系统。</p>
<p>类似于<code>Java</code>中编译器用于区分<code>Java8</code>与<code>Java17</code>这样的不兼容版本。</p>
<p>不同版次编译的代码可以互相依赖不影响使用(2021版次的代码可以引用2015版次编译的库)。</p>
<ol>
<li>2015 Edition</li>
<li>2018 Edition</li>
<li>2021 Edition</li>
</ol>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>crate与模块</title>
    <url>/Rust/basic/crate%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="crate与模块"><a href="#crate与模块" class="headerlink" title="crate与模块"></a>crate与模块</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode中的Rust配置</title>
    <url>/Rust/basic/vscode%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="安装必要插件"><a href="#安装必要插件" class="headerlink" title="安装必要插件"></a>安装必要插件</h1><ul>
<li>rust-analyzer ：Rust 插件</li>
<li>crates ：crate 相关插件</li>
<li>Even Better TOML ：TOML 语法高亮</li>
</ul>
<h1 id="一些非必要但是好用的-crate"><a href="#一些非必要但是好用的-crate" class="headerlink" title="一些非必要但是好用的 crate"></a>一些非必要但是好用的 crate</h1><ul>
<li>cargo-edit: 该工具扩展了Cargo，允许您通过从命令行修改Cargo.toml文件来添加、删除和升级依赖项。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">任意目录下</span></span><br><span class="line">cargo install cargo-edit</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs安装与配置</title>
    <url>/%E5%89%8D%E7%AB%AF/nodejs/nodejs%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://nodejs.org/">Node.js</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下一步即可</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>1.在你需要的目录下新建两个文件夹【node_global】和【node_cache】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\tools\SDK\nodejs\configuration\node_global&quot;</span><br><span class="line"></span><br><span class="line">npm config set cache &quot;D:\tools\SDK\nodejs\configuration\node_cache&quot;</span><br></pre></td></tr></table></figure>

<p>【此电脑】-单击右键【属性】-【高级系统设置】-【环境变量】</p>
<p>2.在【系统变量】中点击【新建】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NODE_PATH</span><br><span class="line">D:\tools\SDK\nodejs\configuration\node_global\node_modules</span><br></pre></td></tr></table></figure>

<p>3.编辑【用户变量】中的【Path】</p>
<p>将默认C盘下【AppData\Roaming\npm】修改为【node_global】的路径</p>
<p>4.在【系统变量】中选择【Path】添加【%NODE_PATH%】</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust编译过程</title>
    <url>/Rust/basic/Rust%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>Rust 编译过程</strong></p>
<p><img src="/public/image/Rust/basic/rust-complie-process.png" alt="rust-complie-process"></p>
<p>直接使用源代码非常不方便且容易出错。因此在我们做任何其他事情之前，我们将原始源代码转换为 AST。即使这样做也涉及大量工作，包括词法分析、解析、 宏扩展、名称解析、条件编译、功能门控 AST的检查和验证。</p>
<p>值得注意的是，这些任务之间并不总是有明确的顺序。例如，宏扩展依赖于名称解析来解析宏和 imports。解析需要宏扩展，而这反过来又可能需要分析宏的输出。</p>
<p><strong>步骤说明</strong>：</p>
<ol>
<li><p>Rust 源码(Unicode字符)作为 <em>UTF-8</em> 编码序列输入到编译器，编译器的 Lexing 会获取字符编码并将他们转换为<code>token Steam</code>，然后解析 token Stream 将它们转换为结构化的编译器更容易使用的表单，通常称为<code>抽象语法树</code>(AST)  。</p>
<p>请注意，在解析为 AST 时 ，Rust编译器会对其进行<em>词法分析</em>包括但不限于宏扩展、名称解析、#[test]实现、panic实现、AST验证、Feature 检查、检索 Lang 项目等。</p>
</li>
<li><p>AST 降低到  <em>HIR</em>(高级中间表示) </p>
<p>HIR 是抽象语法树 (AST) 对编译器更友好的表示形式，很多 Rust 语法糖在这一阶段，已经被脱糖（desugared）处理。比如 <code>for</code> 循环和<code>while(let)</code>在这个阶段会被转为<code>loop</code>，<code>if let</code> 被转为<code>match</code>，普遍<code>impl Trait</code>转换为泛型参数，存在<code>impl Trait</code>转换为虚拟声明<code>existential type</code>等等。</p>
<p>对于编译器来说，所有的版次也就是Edition版本，在到达中间语言层次的时候已经消除了版次差异。</p>
</li>
<li><p>HIR 降低到 <em>THIR</em>(类型化高级中间表示)</p>
<p>THIR 是 rustc 在类型检查后生成的另一种IR，它用于MIR建设、详尽性检查和不安全检查。是一个在在 HIR 的基础上进一步添加了类型信息的版本。</p>
</li>
<li><p>THIR 降级为 <em>MIR</em>(中级中间表示)</p>
<p>它是 Rust 的一种彻底简化的形式，用于 某些对流量敏感的安全检查——特别是借用检查器！– 也用于优化和代码生成。</p>
</li>
</ol>
<blockquote>
<p>Rust 源码(Unicode字符)作为 <em>UTF-8</em> 编码序列输入到编译器，通过分词把词法结构处理为词条流，词条流经过语法解析形成<code>抽象语法树</code>，抽象语法树降级（简化）为<code>高级中间语言</code>（<em>HIR</em>），高级中间语言被用于编译器对代码进行类型检查方法查找等工作，高级中间语言继续降级（简化）为<code>中级中间语言</code>（<em>MIR</em>），中级中间语言被用于借用检查、优化、代码生成（宏、泛型、单态化）等工作，中级中间语言（MIR）优化为<code>LLVM中间语言</code>，最后交给LLVM编译器生成机器码。</p>
</blockquote>
<p><a href="https://rustc-dev-guide.rust-lang.org/the-parser.html">Rust 编译器开发指南</a></p>
<p><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_1/rustc_part1.html">Rust编译器专题 | 图解 Rust 编译器与语言设计 Part 1 - Rust精选</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>定义自己的Crate</title>
    <url>/Rust/basic/%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84Crate/</url>
    <content><![CDATA[<h1 id="创建自己的-Crate"><a href="#创建自己的-Crate" class="headerlink" title="创建自己的 Crate"></a>创建自己的 Crate</h1><p>安装<code>cargo-edit</code>工具，他扩展了<code>cargo</code>的功能</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 项目根目录下下</span></span><br><span class="line"></span><br><span class="line">cargo install cargo<span class="literal">-edit</span></span><br></pre></td></tr></table></figure>

<ul>
<li>cargo add toml：将最新的<code>toml</code> Crate安装到当前项目中，并自动写入当前目录下的<code>Cargo.toml</code>文件中。</li>
</ul>
<h1 id="代码重构实践"><a href="#代码重构实践" class="headerlink" title="代码重构实践"></a>代码重构实践</h1><h1 id="探索引入模块的最佳实践"><a href="#探索引入模块的最佳实践" class="headerlink" title="探索引入模块的最佳实践"></a>探索引入模块的最佳实践</h1>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>异步Web实战</title>
    <url>/Rust/project/%E5%BC%82%E6%AD%A5Web%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><h2 id="rust编码规范"><a href="#rust编码规范" class="headerlink" title="rust编码规范"></a>rust编码规范</h2><p>新建<code>.rustfmt.toml</code>文件用于帮助你写出地道的rust代码。</p>
<p>Rustfmt 的设计非常易于配置。您可以创建一个名为 <code>rustfmt.toml</code>或 的TOML 文件<code>.rustfmt.toml</code>，将其放在项目或任何其他父目录中，它将应用该文件中的选项。</p>
<p>这需要将rust设置为<code>nightly</code>时才可使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustup default nightly</span><br></pre></td></tr></table></figure>

<p>在当前工作目录中的 Cargo 项目上运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo +nightly fmt</span><br><span class="line"></span><br><span class="line"># rustfmt lib.rs main.rs 将就只格式化“lib.rs”和“main.rs”</span><br><span class="line"># rustfmt lib.rs --check 检查 lib.rs 文件的格式，并给出修改意见，不进行格式化</span><br></pre></td></tr></table></figure>

<h2 id="学习axum"><a href="#学习axum" class="headerlink" title="学习axum"></a>学习axum</h2><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p><strong>1.cargo-edit工具</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cargo install cargo<span class="literal">-edit</span></span><br></pre></td></tr></table></figure>

<p><strong>2. Toml文件插件</strong></p>
<p><code>TOML Language Support</code></p>
<p><strong>3. cratescha插件</strong></p>
<p><code>crates</code></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-实战</tag>
      </tags>
  </entry>
  <entry>
    <title>函数和闭包</title>
    <url>/Rust/basic/%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h1 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="常规函数"><a href="#常规函数" class="headerlink" title="常规函数"></a>常规函数</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>函数都拥有显示的类型签名；</li>
<li>函数可分为三种类型：自由函数、关联函数和方法；</li>
<li>函数自身也是一种类型</li>
</ul>
<h4 id="自由函数"><a href="#自由函数" class="headerlink" title="自由函数"></a>自由函数</h4><h4 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h4><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h3 id="函数项类型"><a href="#函数项类型" class="headerlink" title="函数项类型"></a>函数项类型</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> (<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        a + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">math</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span>::<span class="title function_ invoke__">sum</span>(<span class="keyword">self</span>.<span class="number">0</span>, <span class="keyword">self</span>.<span class="number">1</span>) <span class="comment">// 此处存在一个自动解引用 Self::sum((*self).0, (*self).1) </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">A</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add</span>: <span class="keyword">fn</span> <span class="title function_">sum</span>(<span class="type">i32</span>, <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> = A::sum; <span class="comment">// fn sum(i32, i32) -&gt; i32 是函数项类型也就是函数自己本身的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">add_math</span>: <span class="keyword">fn</span> <span class="title function_">math</span>(&amp;A) <span class="punctuation">-&gt;</span> <span class="type">i32</span> = A::math; <span class="comment">// 同上</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add</span>(<span class="number">1</span>, <span class="number">2</span>), A::<span class="title function_ invoke__">sum</span>(<span class="number">1</span>, <span class="number">2</span>));<span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">add_math</span>(&amp;a),a.<span class="title function_ invoke__">math</span>());</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;A)); <span class="comment">// 大小为 0 函数项类型是零大小类型</span></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;a)); <span class="comment">// 大小为 8 (4（i32）+ 4（i32）= 8)</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数指针类型"><a href="#函数指针类型" class="headerlink" title="函数指针类型"></a>函数指针类型</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RGB</span> = (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">color</span>(c: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB &#123;</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shwo</span>(c: <span class="title function_ invoke__">fn</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB) &#123; <span class="comment">// 此处隐式转为了函数指针类型 是 fn(&amp;str) -&gt; RGB 类型</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c); <span class="comment">// 此处指针就是一个地址，所以可以被打印</span></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;c)); <span class="comment">// 8 函数指针大小为 8</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">c</span>(<span class="string">&quot;black&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb</span>: <span class="keyword">fn</span> <span class="title function_">color</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>) = color; <span class="comment">// 函数项类型  fn color(&amp;str) -&gt; (i16, i16, i16)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: <span class="keyword">fn</span> <span class="title function_">color</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>)  = rgb; <span class="comment">// 函数项类型</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, rgb); // 此处是函数项类型不可以被打印</span></span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(rgb);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;rgb)); <span class="comment">// 函数项大小为 0 函数项是零大小类型  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>结论：</strong></p>
<ul>
<li>函数项类型可以通过显式指定函数类型转换为一个函数指针类型；</li>
<li>在写代码的时候，尽可能地去使用 <em>函数项类型</em>，不到万不得已不要使用函数指针类型，这样有助于享受零大小类型的优化；</li>
</ul>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="闭包与函数的异同"><a href="#闭包与函数的异同" class="headerlink" title="闭包与函数的异同"></a>闭包与函数的异同</h3><ol>
<li>闭包可以捕获环境中的自由变量；</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">counter</span>(i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">inc</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">         n + i <span class="comment">// error[E0434]: can&#x27;t capture dynamic environment in a fn item</span></span><br><span class="line">    &#125;</span><br><span class="line">    inc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> = <span class="title function_ invoke__">counter</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">f</span>(<span class="number">1</span>))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可改为：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">counter</span>(i: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">FnMut</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">move</span> | n | n + i <span class="comment">// move 关键字将环境变量 i 的所有权移动到闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span>: <span class="keyword">impl</span> <span class="title class_">FnMut</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> = <span class="title function_ invoke__">counter</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">f</span>(<span class="number">1</span>))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>闭包可以与函数指针互通</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">RGB</span> = (<span class="type">i16</span>, <span class="type">i16</span>, <span class="type">i16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">color</span>(c: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB &#123;</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shwo</span>(c: <span class="title function_ invoke__">fn</span>(&amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> RGB) &#123; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">c</span>(<span class="string">&quot;black&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rgb</span> = color;</span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(rgb); <span class="comment">// (1, 1, 1)</span></span><br><span class="line">    <span class="comment">// 定义了实现`Fn(&amp;str) -&gt; RGB`trait 的闭包类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = | s: &amp;<span class="type">str</span> | &#123; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &#125;; <span class="comment">// 闭包</span></span><br><span class="line">    <span class="title function_ invoke__">shwo</span>(c); <span class="comment">// (1, 2, 3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/blogimg/os/tuos/batch-os-detail.png.png" alt="batch-os-detail.png"></p>
<h3 id="Rust闭包的实现原理"><a href="#Rust闭包的实现原理" class="headerlink" title="Rust闭包的实现原理"></a>Rust闭包的实现原理</h3><h4 id="闭包的使用场景"><a href="#闭包的使用场景" class="headerlink" title="闭包的使用场景"></a>闭包的使用场景</h4><ol>
<li>未捕获环境变量(所有权)</li>
<li>捕获但修改环境变量(可变引用)</li>
<li>捕获但未修改环境变量(不可变引用)</li>
</ol>
<h4 id="未捕获环境变量"><a href="#未捕获环境变量" class="headerlink" title="未捕获环境变量"></a>未捕获环境变量</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 未捕获环境变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = || <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">c1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span>	<span class="comment">// #![feature(...)] 是一种属性，用于启用语言或标准库中的实验性功能</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span>&lt;T&gt; &#123;</span><br><span class="line">    env_var: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	### 标准库 FnOnce trait 的定义</span></span><br><span class="line"><span class="comment">	pub trait FnOnce&lt;Args&gt; &#123;</span></span><br><span class="line"><span class="comment">		type Output;</span></span><br><span class="line"><span class="comment">		extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">FnOnce</span>&lt;()&gt; <span class="keyword">for</span> <span class="title class_">Closure</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">self</span>, args: ()) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Closure &#123; env_var: ()&#125;;</span><br><span class="line">    c.<span class="title function_ invoke__">call_once</span>(());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当你创建闭包的时候，编译器会解析你的闭包，然后生成一个匿名结构体<code>Closure</code>，其中的字段<code>env_var</code>用于存储捕获的自由变量；在上面的场景中闭包未捕获任何变量,所以<code>main</code>函数中创建<code>Closure</code>的字段值用<code>()</code>来表示；</p>
<p>接下来在为这个匿名的结构体<code>Closure</code>实现<code>FnOnce&lt;()&gt;</code>这个trait；其中<code>Arges</code>这个参数是闭包自身的参数，即闭包调用时传入的参数(捕获的环境变量)；</p>
<p>当闭包被调用的时候等价于调用匿名结构体实现的<code>call_once</code>这个方法；该方法会消耗掉该结构体的实例；</p>
</blockquote>
<p><strong>编译器将<code>FnOnce</code>类型的闭包看成是函数指针</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = || &#123; <span class="string">&quot;c1&quot;</span>; &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = || &#123; <span class="string">&quot;c2&quot;</span>; &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [c1, c2]; <span class="comment">// Ok</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="string">&quot;c3&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c3</span> = || &#123; i &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = [c1, c2, c3] <span class="comment">// Error  expected fn pointer, found closure 他把c1, c2当成了函数指针，c3当成了闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="捕获但修改环境变量"><a href="#捕获但修改环境变量" class="headerlink" title="捕获但修改环境变量"></a>捕获但修改环境变量</h4><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 可修改环境变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c2</span> = | i | &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">c2</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="meta">#![feature(unboxed_closures, fn_traits)]</span>	<span class="comment">// #![feature(...)] 是一种属性，用于启用语言或标准库中的实验性功能</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    env_var: [<span class="type">i32</span>, <span class="number">3</span>],  <span class="comment">// 捕获的环境变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 至少需要一个能消耗自身的一个方法，用于在多次调用之间保持并修改状态。</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnOnce</span>&lt;(<span class="type">i32</span>, )&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = ();</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_once</span>(<span class="keyword">mut</span> <span class="keyword">self</span>, args: (<span class="type">i32</span>, )) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">        <span class="keyword">self</span>.env_var[<span class="number">0</span>] = args.<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.env_var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	### 标准库 FnMut trait 的定义</span></span><br><span class="line"><span class="comment">	pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; &#123;</span></span><br><span class="line"><span class="comment">		type Output;</span></span><br><span class="line"><span class="comment">		extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FnMut</span>&lt;(<span class="type">i32</span>, )&gt; <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="string">&quot;rust-call&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_mut</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: (<span class="type">i32</span>, )) <span class="punctuation">-&gt;</span> () &#123;</span><br><span class="line">            <span class="keyword">self</span>.env_var[<span class="number">0</span>] = args.<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.env_var);</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">c</span> = Closuse &#123; env_var: arr &#125;;</span><br><span class="line">    <span class="comment">// c.call_once((0, ));</span></span><br><span class="line">    c.<span class="title function_ invoke__">call_mut</span>((<span class="number">0</span>, ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="捕获但未修改环境变量"><a href="#捕获但未修改环境变量" class="headerlink" title="捕获但未修改环境变量"></a>捕获但未修改环境变量</h4><p>代码逻辑同上，多了一个Fn</p>
<h3 id="闭包的具体分类"><a href="#闭包的具体分类" class="headerlink" title="闭包的具体分类"></a>闭包的具体分类</h3>]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>bevy基础</title>
    <url>/game/rust/Bevy/bevy%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Bevy-基础"><a href="#Bevy-基础" class="headerlink" title="Bevy 基础"></a>Bevy 基础</h1><h2 id="Bevy设置"><a href="#Bevy设置" class="headerlink" title="Bevy设置"></a>Bevy设置</h2><h3 id="加快编译优化"><a href="#加快编译优化" class="headerlink" title="加快编译优化"></a>加快编译优化</h3><p>在<code>Cargo.toml</code>或<code>.cargo/config.toml</code>:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对依赖项启用最大优化，但不对我们的代码启用最大优化：</span></span><br><span class="line"><span class="section">[profile.dev.package.&quot;*&quot;]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在调试/开发模式下仅启用少量优化</span></span><br><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际发布模式下最积极的优化配置：</span></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">lto</span> = <span class="literal">true</span> <span class="comment"># 设置为 true 时编译器会进行链接时间优化，但会增加编译时间。</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span> <span class="comment"># 设置优化级别为最高。</span></span><br><span class="line"><span class="attr">codegen-units</span> = <span class="number">1</span> <span class="comment"># 控制了代码生成的单元数量。当设置为 1 时，整个 crate 会被编译成一个单独的代码生成单元。</span></span><br><span class="line"><span class="attr">incremental</span> = <span class="literal">false</span> <span class="comment"># 不启用增量编译：增量编译允许 Cargo 只重新编译自上次构建以来已更改的文件和依赖项，从而加快编译速度。</span></span><br><span class="line"><span class="attr">debug</span> = <span class="literal">false</span> <span class="comment"># 当设置为false时，编译器不会生成调试信息。</span></span><br></pre></td></tr></table></figure>

<p><strong>警告！</strong>如果您使用调试器（如<code>gdb</code>或<code>lldb</code>）来逐步执行代码，任何程度的编译器优化都会影响体验。您的断点可能会被跳过，并且代码流可能会以意想不到的方式跳来跳去。如果您想调试&#x2F;逐步执行代码，您可能需要 <code>opt-level = 0</code>。</p>
<h3 id="加速-Rust-Analyzer"><a href="#加速-Rust-Analyzer" class="headerlink" title="加速 Rust-Analyzer"></a>加速 Rust-Analyzer</h3><p><em>Powershell</em> 中键入 <strong>rustup shwo</strong> 来显示你的Rust构建工具链</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\cnkay&gt; rustup show</span><br><span class="line">Default host: x86_64<span class="literal">-pc-windows-msvc</span></span><br><span class="line">rustup home:  D:\tools\SDK\rust\.rustup</span><br><span class="line"></span><br><span class="line">stable<span class="literal">-x86_64-pc-windows-msvc</span> (default)</span><br><span class="line">rustc <span class="number">1.78</span>.<span class="number">0</span> (<span class="number">9</span>b00956e5 <span class="number">2024</span><span class="literal">-04-29</span>)</span><br></pre></td></tr></table></figure>

<p>如果你使用的是 <em>MSVC</em> 工具链那么连接器是<code>link.exe</code>。</p>
<p>为了实现快速编译，需要设置非默认链接器。在 <em>VSCode</em> 中设置<code>settings.json</code> 添加：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Windows<span class="punctuation">:</span></span><br><span class="line"><span class="attr">&quot;rust-analyzer.cargo.extraEnv&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;RUSTFLAGS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-Clinker=rust-lld.exe&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">Linux(mold)<span class="punctuation">:</span></span><br><span class="line"><span class="attr">&quot;rust-analyzer.cargo.extraEnv&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;RUSTFLAGS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-Clinker=clang -Clink-arg=-fuse-ld=mold&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">Linux (lld)<span class="punctuation">:</span></span><br><span class="line"><span class="attr">&quot;rust-analyzer.cargo.extraEnv&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;RUSTFLAGS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-Clinker=clang -Clink-arg=-fuse-ld=lld&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CI设置"><a href="#CI设置" class="headerlink" title="CI设置"></a>CI设置</h2><p><code>CI</code>是<strong>GitHub Actions</strong>的简称</p>
<h2 id="ECS-模式"><a href="#ECS-模式" class="headerlink" title="ECS 模式"></a>ECS 模式</h2><p>ECS 是*实体(Entity)<em>、</em>组件(Component)<em>、</em>系统(System)*的简称，是一种将<strong>数据</strong>和<strong>行为</strong>分开的编程范式。</p>
<p><strong>系统(System)</strong></p>
<p>系统是处理实体和组件的逻辑单元，负责执行特定的功能或行为。</p>
<p>系统是基于组件的存在于否，以及它们的状态来执行逻辑单元。</p>
<p>系统通常是独立于特定实体的，可以处理多个具有相似组件结构的实体。</p>
<p><strong>实体(Entity)</strong></p>
<p>实体是系统中的基本对象，可以是游戏中的角色、物体或者其他有意义的实体。</p>
<p>实体本身通常只是一个标识符，没有行为或状态。</p>
<p><strong>组件(Component)</strong></p>
<p>组件是实体的属性或数据单元，描述了实体的特征和状态。</p>
<p>不同的组件可以包含不同类型的数据，例如位置、渲染信息、健康状态等。</p>
<p>一个实体可以关联多个组件，组件之间是相互独立的。</p>
<p><strong>总结</strong></p>
<p><strong>实体只是指向组件的唯一ID或引用，本质上他将所有的组件连接在一起，构成游戏中的单个对象。</strong></p>
<p><strong>组件只是存粹的数据结构，如坦克对象的大小和速度。</strong></p>
<p><strong>系统只是对具有特定组件功能的实体进行操作的功能。</strong></p>
<p>在Bevy中<strong>实体(Entity)</strong> 是指向一群<strong>组件(Component)</strong> 的唯一 <strong>事物(things)</strong>, 然后使用 <strong>系统(System)</strong> 处理其过程.</p>
<p>例如，一个实体可能有<code>位置(Position)</code>和<code>速度(Velocity)</code>组件，而另一个实体可能有<code>位置(Position)</code>和<code>UI</code>组件。系统是在一组特定组件上运行的逻辑， 你可能有一个运行在所有带有<code>位置(Position)</code>和<code>速度(Velocity)</code>组件的实体上的<code>移动</code>系统。</p>
<h2 id="ECS-中的数据"><a href="#ECS-中的数据" class="headerlink" title="ECS 中的数据"></a>ECS 中的数据</h2><h3 id="World"><a href="#World" class="headerlink" title="World"></a>World</h3><p>定义：<em>World</em>是<strong>系统</strong>和<strong>实体</strong>的集合。在<code>ECS</code>架构中，<em>World</em>是最高级别的组织单位，它包含了<strong>游戏中的所有实体（Entity）以及处理这些实体的系统（System）</strong>。</p>
<p>当程序启动时，默认会生成一个World,可以存在多个World对象。</p>
<h3 id="Entities-Components"><a href="#Entities-Components" class="headerlink" title="Entities&#x2F;Components"></a>Entities&#x2F;Components</h3><p>概念上类似于在数据库或电子表格。</p>
<p>每一行数据就是一个对象，<code>(Entity)</code>与<code>ID</code>或者行号类似，<code>(Components)</code>类似于 表的<em>列</em>，可以有任意多个<em>行</em>。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实体</span></span><br><span class="line"><span class="meta">#[derive(Component)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Xp</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="meta">#[derive(Component)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Health</span> &#123;</span><br><span class="line">    current: <span class="type">u32</span>,</span><br><span class="line">    max: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">level_up</span>(<span class="keyword">mut</span> query: Query&lt;(&amp;<span class="keyword">mut</span> Xp, &amp;<span class="keyword">mut</span> Health)&gt;,) &#123;</span><br><span class="line">    <span class="comment">// process all relevant entities</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">mut</span> xp, <span class="keyword">mut</span> health) <span class="keyword">in</span> query.<span class="title function_ invoke__">iter_mut</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> xp.<span class="number">0</span> &gt; <span class="number">1000</span> &#123;</span><br><span class="line">            xp.<span class="number">0</span> -= <span class="number">1000</span>;</span><br><span class="line">            health.max += <span class="number">25</span>;</span><br><span class="line">            health.current = health.max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>如果某物只有一个全局实例（单例），并且它是独立（不与其他数据关联），那么你就可以创建一个<code>Resources</code></p>
<p>例如，您可以创建一个资源来存储游戏的图形 设置，或指向非 Bevy 库的接口。</p>
<p>这是一种存储数据的简单方法，当你不需要<code>实体/组件</code>的灵活性的时候。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Resource)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GameSettings</span> &#123;</span><br><span class="line">    current_level: <span class="type">u32</span>,</span><br><span class="line">    difficulty: <span class="type">u32</span>,</span><br><span class="line">    max_time_seconds: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">setup_game</span>(</span><br><span class="line">    <span class="keyword">mut</span> commands: Commands,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// Add the GameSettings resource to the ECS</span></span><br><span class="line">    <span class="comment">// (if one already exists, it will be overwritten)</span></span><br><span class="line">    commands.<span class="title function_ invoke__">insert_resource</span>(GameSettings &#123;</span><br><span class="line">        current_level: <span class="number">1</span>,</span><br><span class="line">        difficulty: <span class="number">100</span>,</span><br><span class="line">        max_time_seconds: <span class="number">60</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">spawn_extra_enemies</span>(</span><br><span class="line">    <span class="keyword">mut</span> commands: Commands,</span><br><span class="line">    <span class="comment">// we can easily access our resource from any system</span></span><br><span class="line">    game_settings: Res&lt;GameSettings&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> game_settings.difficulty &gt; <span class="number">50</span> &#123;</span><br><span class="line">        commands.<span class="title function_ invoke__">spawn</span>((</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
</search>
